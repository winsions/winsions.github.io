<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python在Apache上配置CGI服务]]></title>
      <url>%2F2017%2F08%2F08%2FPython%E5%9C%A8Apache%E4%B8%8A%E9%85%8D%E7%BD%AECGI%E6%9C%8D%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[Python在Apache上配置CGI服务 配置apache 能够运行，Itworks 修改httpd.conf文件 123456789101112131415161718192021修改成： DocumentRoot &quot;/Users/deng/Sites” # 能直接访问HTML的位置&lt;Directory &quot;/Users/deng/Sites&quot;&gt; ScriptAlias /cgi-bin/ &quot;/Users/deng/Sites/cgi/&quot; # /Users/deng/Sites/cgi/存放服务器文件的地方 如果注释了下面两句，就取消注释 AddType text/html .shtml AddOutputFilter INCLUDES .shtml 在文件最后加上以下内容 LoadModule cgi_module libexec/mod_cgi.so LoadModule cgid_module libexec/mod_cgid.so AddHandler cgi-script .cgi .sh .pl .py &lt;Directory &quot;/Users/deng/Sites/cgi/&quot;&gt; Options ExecCGI AllowOverride None Order deny,allow Allow from all &lt;/Directory&gt; 3.设置权限 123chmod +x /Users/deng/Sites chmod +x /Users/deng/Sites/cgi chmod +x /Users/deng/Sites/cgi/first.pl]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python的学习]]></title>
      <url>%2F2017%2F08%2F06%2FPython%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[Python的学习标识符 标识符由数字，字母，下划线组成，不能由数字开头，区分大小写 下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入以双下划线开头的 foo 代表类的私有成员；以双下划线开头和结尾的 foo 代表 Python 里特殊方法专用的标识，如 init__() 代表类的构造函数。python可以一行显示多条语句，用分号隔开 Python 保留字符 下面的列表显示了在Python中的保留字。这些保留字不能用作常数或变数，或任何其他标识符名称。所有 Python 的关键字只包含小写字母。 12345678910and exec notassert finally orbreak for passclass from printcontinue global raisedef if returndel import tryelif in whileelse is withexcept lambda yield 行和缩进 学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示： 1234if True: print &quot;True&quot;else: print &quot;False&quot; 执行以上代码，会出现如下错误提醒： 12345$ python test.py File &quot;test.py&quot;, line 5 if True: ^IndentationError: unexpected indent IndentationError: unexpected indent 错误是 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有 python 对格式要求非常严格。如果是 IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。因此，在 Python 的代码块中必须使用相同数目的行首缩进空格数。建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用 多行语句Python语句中一般以新行作为为语句的结束符。但是我们可以使用斜杠（ \）将一行的语句分为多行显示，如下所示： 1234567891011121314151617181920212223242526272829total = item_one + \ item_two + \ item_three语句中包含 [], &#123;&#125; 或 () 括号就不需要使用多行连接符。如下实例：days = [&apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;]Python 引号Python 可以使用引号( &apos; )、双引号( &quot; )、三引号( &apos;&apos;&apos; 或 &quot;&quot;&quot; ) 来表示字符串，引号的开始与结束必须的相同类型的。其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。word = &apos;word&apos;sentence = &quot;这是一个句子。&quot;paragraph = &quot;&quot;&quot;这是一个段落。包含了多个语句&quot;&quot;&quot;Python注释python中单行注释采用 # 开头。#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：test.py# 第一个注释print &quot;Hello, Python!&quot;; # 第二个注释输出结果：Hello, Python!注释可以在语句或表达式行末：name = &quot;Madisetti&quot; # 这是一个注释python 中多行注释使用三个单引号(&apos;&apos;&apos;)或三个双引号(&quot;&quot;&quot;)。#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：test.py ‘’’这是多行注释，使用单引号。这是多行注释，使用单引号。这是多行注释，使用单引号。‘’’ “””这是多行注释，使用双引号。这是多行注释，使用双引号。这是多行注释，使用双引号。“”” Python空行 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。记住：空行也是程序代码的一部分。 输入输出 等待用户输入 123456789101112下面的程序执行后就会等待用户输入，按回车键后就会退出：#!/usr/bin/pythonraw_input(&quot;\n\nPress the enter key to exit.&quot;)以上代码中 ，&quot;\n\n&quot;在结果输出前会输出两个新的空行。一旦用户按下 enter(回车) 键退出，其它键显示。同一行显示多条语句Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：#!/usr/bin/pythonimport sys; x = &apos;runoob&apos;; sys.stdout.write(x + &apos;\n&apos;)执行以上代码，输入结果为：$ python test.pyrunoob Print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号： 123456789101112131415161718#!/usr/bin/python# -*- coding: UTF-8 -*-x=&quot;a&quot;y=&quot;b&quot;# 换行输出print xprint yprint &apos;---------&apos;# 不换行输出print x,print y,以上实例执行结果为：ab---------a b]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS面试宝典]]></title>
      <url>%2F2017%2F07%2F13%2FiOS%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%2F</url>
      <content type="text"><![CDATA[block 和week的区别 block不管是在ARC下还是在MRC下都可以使用，可以修饰对象和基本数据类型，回调代码段，代替代理， week只能在ARC模式下使用，只能修饰对象string，而不能修饰基本数据类型 block可以在block中重新赋值，week不可以 tableview滑动卡顿的问题 从缓存或者本地读取图片给UIimage的时候消耗的时间。 把uiiage赋值给图片的时候要在主线程 子线程中加入nstimer的时候需要手动添加nsrunloop，否则不能循环 创建子线程时，GCD里面用_weak防止内存释放不了，循环引用 sd_webimage的实现原理 先显示ploceholder，然后sd开始根据url处理图片 从缓存中SDwebiamgeCache中查看缓存中是否已经下载图片， 已经下载，则调用SDwebiamgeCacheDelegate回调，SDwebiamgeManager回调显示前段图片 如果没有则看硬盘中是否存在，根据urlkey，读取硬盘，如果有则添加到内存中，进而回调照片 如果没有图片，则需要下载图片，sdwebiamgedownloader，用NSurlConnection来做，根据delegate来判断图片下载的中完成和失败 图片下载完成后，回调给需要展示的地方，保存在内存和硬盘中网络请求状态码302：请求重定向 500：服务器错误 400：请求连接错误或者找不到服务器 200以上是正确 子线程 dispatch-asyncGCD 网络数据的读取，数据库的读取，图片的下载，排序，耗时大的东西 123456dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //耗时操作 dispatch_async(dispatch_get_main_queue(), ^&#123; //更新界面 &#125;); &#125;); dispatch_group_async的使用创建队列在队列中添加任务，当所有的任务都完成之后能发出通知 copy和retain的区别 copy其实是建立一个相同的对象，retain不是 copy是内容的copy，retain是指针的拷贝。（指针就是指向地址的变量） copy对于NSStrig的确是内容，但是对于NSArray呢，这时只是指向了array中相对元素的指针，这便是浅copy objc的内存管理?? 如果您通过分配和初始化（比如[[MyClass alloc] init]）的方式来创建对象，您就拥有这个对象，需要负责该对象的释放。这个规则在使用NSObject的便利方法new 时也同样适用。?? 如果您拷贝一个对象，您也拥有拷贝得到的对象，需要负责该对象的释放。?? 如果您保持一个对象，您就部分拥有这个对象，需要在不再使用时释放该对象。反过来，?? 如果您从其它对象那里接收到一个对象，则您不拥有该对象，也不应该释放它（这个规则有少数的例外，在参考文档中有显式的说明）。 类工厂方法是什么类工厂方法的实现是为了向客户提供方便，它们将分配和初始化合在一个步骤中，返回被创建的对象，并进行自动释放处理。这些方法的形式是+ (type)className…（其中 className不包括任何前缀）。工厂方法可能不仅仅为了方便使用。它们不但可以将分配和初始化合在一起，还可以为初始化过程提供对象的分配信息。类工厂方法的另一个目的是使类（比如NSWorkspace）提供单件实例。虽然init…方法可以确认一个类在每次程序运行过程只存在一个实例，但它需要首先分配一个“生的”实例，然后还必须释放该实例。工厂方法则可以避免为可能没有用的对象盲目分配内存。 obj-c的优缺点objc优点： 1) Cateogies 2) Posing 3) 动态识别 4) 指标计算 5）弹性讯息传递 6) 不是一个过度复杂的 C 衍生语言 7) Objective-C 与 C++ 可混合编程缺点: 1) 不支援命名空间 2) 不支持运算符重载 3）不支持多重继承 不可以多重继承，可以遵守多个协议，来代替这个工能，继承可以增加修改删除原来的方法，换可以增加属性， 4）使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。（如内联函数等），性能低劣。 readwrite，readonly，assign，retain，copy，nonatomic属性的作用@property是一个属性访问声明，扩号内支持以下几个属性：1，getter=getterName，setter=setterName，设置setter与getter的方法名2，readwrite,readonly，设置可供访问级别2，assign，setter方法直接赋值，不进行任何retain操作，为了解决原类型与环循引用问题3，retain，setter方法对参数进行release旧值再retain新值，所有实现都是这个顺序(CC上有相关资料)4，copy，setter方法进行Copy操作，与retain处理流程一样，先旧值release，再Copy出新的对象，retainCount为1。这是为了减少对上下文的依赖而引入的机制。copy是在你不希望a和b共享一块内存时会使用到。a和b各自有自己的内存。5，nonatomic，非原子性访问，不加同步，多线程并发访问会提高性能。 什么是KVC和KVO？答：KVC(Key-Value-Coding)内部的实现：一个对象在调用setValue的时候，（1）首先根据方法名找到运行方法的时候所需要的环境参数。（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。（3）再直接查找得来的具体的方法实现。KVO（Key-Value- Observing）：当观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类，而不是真实的类。所以 isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名 oc中的协议和java中的接口概念有何不同？答案：OC中的代理有2层含义，官方定义为 formal和informal protocol。前者和Java接口一样。informal protocol中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就会改变类的属性。其实关于正式协议，类别和非正式协议我很早前学习的时候大致看过，也写在了学习教程里“非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的方法，你可以使用他们更好的完成工作”。这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会申明一个这样的类别去实现。然后你在后期可以直接使用这些更好的方法。这么看，总觉得类别这玩意儿有点像协议的可选协议。”现在来看，其实protocal已经开始对两者都统一和规范起来操作，因为资料中说“非正式协议使用interface修饰“，现在我们看到协议中两个修饰词：“必须实现(@requied)”和“可选实现(@optional)”。 我们说的oc是动态运行时语言是什么意思？答案：多态。主要是将数据类型的确定由编译时，推迟到了运行时。这个问题其实浅涉及到两个概念，运行时和多态。简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat;那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。也就是不同的对象以自己的方式响应了相同的消息（响应了eat这个选择器）。因此也可以说，运行时机制是多态的基础？~~~ 36NSOperation queue?答案：存放NSOperation的集合类。操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。网上部分资料提到一点是，虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。这边又有个疑点是，对于队列来说，先进先出的概念是Afunc添加进队列，Bfunc紧跟着也进入队列，Afunc先执行这个是必然的，但是Bfunc是等Afunc完全操作完以后，B才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。但是转念一想其实可以参考银行的取票和叫号系统。因此对于A比B先排队取票但是B率先执行完操作，我们亦然可以感性认为这还是一个队列。但是后来看到一票关于这操作队列话题的文章，其中有一句提到“因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”瞬间觉得这个queue名字有点忽悠人了，还不如pool~综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。 HTTP协议详解HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中。 http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。HTTP协议的主要特点可概括如下：1.支持客户/服务器模式。2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 URLHTTP URL (URL是一种特殊类型的URI是他的子类，包含了用于查找某个资源的足够的信息)的格式如下：http://host[&quot;:&quot;port][abs_path]http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。 49TCP/UDP区别联系 TCP—传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。 UDP—用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快 TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，我们来看看这三次对话的简单过程：1.主机A向主机B发出连接请求数据包；2.主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包；3.主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。tcp协议和udp协议的差别是否连接面向连接面向非连接传输可靠性可靠不可靠应用场合传输大量数据少量数据速度慢快50socket连接和http连接的区别 简单说，你浏览的网页（网址以http://开头)都是http协议传输到你的浏览器的, 而http是基于socket之上的。socket是一套完成tcp，udp协议的接口。HTTP协议：简单对象访问协议，对应于应用层 ，HTTP协议是基于TCP连接的 tcp协议： 对应于传输层 ip协议： 对应于网络层TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。 Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。 http连接：http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断掉； socket连接：socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；但是由于各种环境因素可能会是连接断开，比如说：服务器端或客户端主机down了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以释放网络资源。所以当一个socket连接中没有数据的传输，那么为了维持连接需要发送心跳消息~~具体心跳消息格式是开发者自己定义的 我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。1)Socket是一个针对TCP和UDP编程的接口，你可以借助它建立TCP连接等等。而TCP和UDP协议属于传输层 。 而http是个应用层的协议，它实际上也建立在TCP协议之上。 (HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。) 2）Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口。 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。1。服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。 2。客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。 3。连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 进程与线程进程（process）是一块包含了某些资源的内存区域。操作系统利用进程把它的工作划分为一些功能单元。 进程中所包含的一个或多个执行单元称为线程（thread）。进程还拥有一个私有的虚拟地址空间，该空间仅能被它所包含的线程访问。 通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度。简而言之,一个程序至少有一个进程,一个进程至少有一个线程.一个程序就是一个进程，而一个程序中的多个任务则被称为线程。 线程只能归属于一个进程并且它只能访问该进程所拥有的资源。当操作系统创建一个进程后，该进程会自动申请一个名为主线程或首要线程的线程。应用程序（application）是由一个或多个相互协作的进程组成的。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 多线程多线程编程是防止主线程堵塞，增加运行效率等等的最佳方法。而原始的多线程方法存在很多的毛病，包括线程锁死等。在Cocoa中，Apple提供了NSOperation这个类，提供了一个优秀的多线程编程方法。本次介绍NSOperation的子集，简易方法的NSInvocationOperation： 一个NSOperationQueue 操作队列，就相当于一个线程管理器，而非一个线程。因为你可以设置这个线程管理器内可以并行运行的的线程数量等等 oc语法里的@perpoerty不用写@synzhesize了，自动填充了。并且的_name;写方法时候不用提前声明。llvm 全局方法便利。枚举类型。enum hello:Integer{ } 冒号后面直接可以跟类型，以前是：enum hello{} 后面在指定为Integer .桥接。ARC 自动release retain 的时候 CFString CFArray . Core Fountion. 加上桥接_brige 才能区分CFString 和NSString 而现在自动区分了，叫固定桥接。 下拉刷新封装好了。UICollectionViewController. 可以把表格分成多列。 Social Framework(社交集成)UIActivityViewController来询问用户的社交行为 缓存：就是存放在临时文件里，比如新浪微博请求的数据，和图片，下次请求看这里有没有值。 堆和栈上的指针指针所指向的这块内存是在哪里分配的,在堆上称为堆上的指针,在栈上为栈上的指针.在堆上的指针,可以保存在全局数据结构中,供不同函数使用访问同一块内存.在栈上的指针,在函数退出后,该内存即不可访问. 什么是指针的释放?具体来说包括两个概念.1 释放该指针指向的内存,只有堆上的内存才需要我们手工释放,栈上不需要.2 将该指针重定向为NULL. 数据结构中的指针?其实就是指向一块内存的地址,通过指针传递,可实现复杂的内存访问.7 函数指针?指向一块函数的入口地址. 8 指针作为函数的参数?比如指向一个复杂数据结构的指针作为函数变量这种方法避免整个复杂数据类型内存的压栈出栈操作,提高效率.注意:指针本身不可变,但指针指向的数据结构可以改变. 9 指向指针的指针?指针指向的变量是一个指针,即具体内容为一个指针的值,是一个地址.此时指针指向的变量长度也是4位. 指针与地址的区别?区别:1指针意味着已经有一个指针变量存在,他的值是一个地址,指针变量本身也存放在一个长度为四个字节的地址当中,而地址概念本身并不代表有任何变量存在.2 指针的值,如果没有限制,通常是可以变化的,也可以指向另外一个地址. 地址表示内存空间的一个位置点,他是用来赋给指针的,地址本身是没有大小概念,指针指向变量的大小,取决于地址后面存放的变量类型.62指针与数组名的关系? 其值都是一个地址,但前者是可以移动的,后者是不可变的. 12 怎样防止指针的越界使用问题? 必须让指针指向一个有效的内存地址,1 防止数组越界2 防止向一块内存中拷贝过多的内容3 防止使用空指针4 防止改变const修改的指针5 防止改变指向静态存储区的内容6 防止两次释放一个指针7 防止使用野指针. 13 指针的类型转换?指针转换通常是指针类型和void * 类型之前进行强制转换,从而与期望或返回void指针的函数进行正确的交接.63static有什么用途？（请至少说明两种） 1.限制变量的作用域 2.设置变量的存储域 7. 引用与指针有什么区别？ 1) 引用必须被初始化，指针不必。 2) 引用初始化以后不能被改变，指针可以改变所指的对象。 2) 不存在指向空值的引用，但是存在指向空值的指针。 8. 描述实时系统的基本特性 在特定时间内完成特定的任务，实时性与可靠性 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？全局变量储存在静态数据库，局部变量在堆栈 10. 什么是平衡二叉树？ 左右子树都是平衡二叉树且左右子树的深度差值的绝对值不大于1 65堆栈溢出一般是由什么原因导致的？ 没有回收垃圾资源 12. 什么函数不能声明为虚函数？ constructor 13. 冒泡排序算法的时间复杂度是什么？ O(n^2) 14. 写出float x 与“零值”比较的if语句。 if(x&gt;0.000001&amp;&amp;x&lt;-0.000001) 16. Internet采用哪种网络协议？该协议的主要层次结构？ tcp/ip 应用层/传输层/网络层/数据链路层/物理层 17. Internet物理地址和IP地址转换采用什么协议？ ARP (Address Resolution Protocol)（地址解析協議） 18.IP地址的编码分为哪俩部分？ IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区 分哪些是网络位哪些是主机位。 2.用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写 出C程序。 循环链表，用取余操作做 3.不能做switch()的参数类型是： switch的参数不能为实型。 華為 1、局部变量能否和全局变量重名？ 答：能，局部会屏蔽全局。要用全局变量，需要使用&quot;::&quot; 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而 不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变 量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那 个循环体内 2、如何引用一个已经定义过的全局变量？ 答：extern 可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个 在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你 用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期 间报错 3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？ 答：可以，在不同的C文件中以static形式来声明同名全局变量。 可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋 初值，此时连接不会出错 4、语句for( ；1 ；)有什么问题？它是什么意思？ 答：和while(1)相同。 5、do……while和while……do有什么区别？ 答：前一个循环一遍再判断，后一个判断以后再循环 661.IP Phone的原理是什么? IPV6 2.TCP/IP通信建立的过程怎样，端口有什么作用？ 三次握手，确定是哪个应用程序使用该协议 3.1号信令和7号信令有什么区别，我国某前广泛使用的是那一种？ 4.列举5种以上的电话新业务？ 微软亚洲技术中心的面试题！！！ 1．进程和线程的差别。 线程是指进程内的一个执行单元,也是进程内的可调度实体. 与进程的区别: (1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 (2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 (3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属 于进程的资源. (4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开 销明显大于创建或撤消线程时的开销。 2.测试方法 人工测试：个人复查、抽查和会审 机器测试：黑盒测试和白盒测试 2．Heap与stack的差别。 Heap是堆，stack是栈。 Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。 Stack空间有限，Heap是很大的自由存储区 C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。 程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的 传递也在栈上进行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之实际网络状态连接检测]]></title>
      <url>%2F2017%2F05%2F05%2FiOS%E4%B9%8B%E5%AE%9E%E9%99%85%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E8%BF%9E%E6%8E%A5%E6%A3%80%E6%B5%8B%2F</url>
      <content type="text"><![CDATA[iOS之实际网络状态连接检测网络连接状态检测对于我们的iOS app开发来说是一个非常通用的需求但事实上，基于此方案的所有实现，都无法帮助我们检测真正的网络连接状态，它们能检测的只是本地连接状态；如下场景就不能检测到: 1231. 现在很流行的公用wifi，需要网页鉴权，鉴权之前无法上网，但本地连接已经建立；2. 存在了本地网络连接，但信号很差，实际无法连接到服务器；3. iOS连接的路由设备本身没有连接外网。 [Reachability reachabilityWithHostName:]完全没用！ RealReachability简单介绍https://github.com/dustturtle/RealReachability可以办到多方研究后引入了ping能力（此方案流量开销最小，也最简单），实现了简单的实际网络连接监测 集成和使用介绍集成最简便的集成方法当属pod: pod ‘RealReachability’。 手动集成：将RealReachability文件夹加入到工程即可。 使用介绍其接口的设计和调用方法和Reachability非常相似，大家可以无缝上手，非常方便。 开启网络监听： 123 [GLobalRealReachability startNotifier]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkChanged:)name:kRealReachabilityChangedNotificationobject:nil]; 回调代码示例： 123456- (void)networkChanged:(NSNotification *)notification&#123; RealReachability *reachability = (RealReachability *)notification.object; ReachabilityStatus status = [reachability currentReachabilityStatus]; NSLog(@&quot;currentStatus:%@&quot;,@(status));&#125; 触发实时网络状态查询代码示例： 123456789101112131415161718192021222324[GLobalRealReachability reachabilityWithBlock:^(ReachabilityStatus status) &#123; switch (status) &#123; case NotReachable: &#123; // case NotReachable handler break; &#125; case ReachableViaWiFi: &#123; // case ReachableViaWiFi handler break; &#125; case ReachableViaWWAN: &#123; // case ReachableViaWWAN handler break; &#125; default: break; &#125; &#125;]; 查询当前实际网络连接状态： 1ReachabilityStatus status = [reachability currentReachabilityStatus]; realReachability架构概要图RealReachability主要包含3大模块：connection、ping、FSM； 其中Ping模块通过对同样是苹果提供的ping样例代码进行了封装，connection模块实现了基于SCNetworkReachability的本地状态检测，FSM模块是有限状态机。通过FSM的状态管理控制connection模块和Ping模块协同工作，并通过可配置的定时策略等业务逻辑优化，最终得到了我们的实现。 其中connection模块和ping模块也可独立使用，分别提供本地网络检测和ping的能力，感兴趣的读者也可以尝试（调用方式请参考RealReachability开源代码）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之抽屉MMDrawerController]]></title>
      <url>%2F2017%2F05%2F04%2FiOS%E4%B9%8B%E6%8A%BD%E5%B1%89MMDrawerController%2F</url>
      <content type="text"><![CDATA[MMDrawerControllerhttps://github.com/Flyfishering/MMDrawerController这是一个抽屉导航控制器, 越来越多的应用开始使用抽屉效果, 这个库是 轻量级的 抽屉导航控制器 创建 MMDrawerControllerMMDrawerController 是一个容器控制器(和 UINavigationController或者UITabBarController相似)拥有三个自控制器,中部,左边抽屉,右边抽屉,创建 MMDrawerController 前必须先创建上面提到的三个自控制器(左中右),然后调用下面给出的初始化方法 来初始化 1234-(instancetype)initWithCenterViewController:(UIViewController *)centerViewController leftDrawerViewController:(UIViewController *)leftDrawerViewController rightDrawerViewController:(UIViewController *)rightDrawerViewController; UINavigationController 可以作为 中部 的子控制器MMDrawerController 自动支持 UINavigationController 作为 中部 自控制器, 可以正确管理view上的手势(无论是navigation bar view 还是 viewController 的view).这个库 也支持包含 其他控制器容器, 这时 手势开关 不接受定制 从子控制器 获取 MMDrawerController子控制器 可以通过 分类(UIViewController+MMDrawerController) 来 获取关于 容器 MMDrawerController 的信息即使 子控制器 包含在 UINavigationController 中, 在这个库中 自控制器的 容器 默认是 MMDrawerController .更多 关于 这个分类的信息, 去该分类中查看MMDrawerOpenCenterInteractionMode控制了 当抽屉打开时 用户和中部控制器交互的模式. 默认是 MMDrawerOpenCenterInteractionModeNavigationBarOnly 只允许 中部控制器的导航栏可以交互,MMDrawerOpenCenterInteractionModeNone: 禁止用户和中部控制器有任何交互MMDrawerOpenCenterInteractionModeFull: 用户可以和中部控制器任何地方交互注意: 无论设置什么模式, 都不会影响 单击中部控制器 的 手势 去关闭抽屉(MMCloseDrawerGestureMode)540832-54821bf1d9792d17.gif 如上图: ##选择OPEN CENTER INTERACTION MODE None 无法滑动 中间控制器 不能点击导航栏 菜单按钮Full 可滑动 中间控制器 可以点击 导航栏 菜单按钮Nav Bar Only 不能滑动 中间控制器 可以点击 导航栏 菜单按钮打开和关闭 抽屉的手势每个抽屉实例都被添加了 两个手势, 拖动手势 和 单击手势,MMDrawerController 识别这些手势,根据打开和关闭手势的识别 和 抽屉控制器的当前状态, 来决定 这个手势 是否 传递下去启用 重用标志为了 恢复 MMDrawerController ,你必须给 中部控制器,左边抽屉,右边抽屉 和 MMDrawerController 设置重用标志restorationIdentifier, 这样, 你的应用在 进入后台 或者下次启动时 会 存储 抽屉的打开状态.这个库 不支持 下面的操作1.不支持 顶部 或者 底部 抽屉2.不支持 同时 打开 左右 抽屉3.不支持 显示最小抽屉宽度(没看懂)4.不支持 将容器控制器设置为 中部控制器 (UINavigationController 除外)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之动画Lottie]]></title>
      <url>%2F2017%2F05%2F04%2FiOS%E4%B9%8B%E5%8A%A8%E7%94%BBLottie%2F</url>
      <content type="text"><![CDATA[什么是Lottie？首先要说的是：什么是Lottie呢？由Airbnb开发的Lottie是一个将After Effects动画提供给任意一个iOS，macOS，Android还有React Native原生APP的文件库。这些动画通过一个叫Bodymovin的开源After Effects插件，以JSON文件的形式进行输出。Lottie通过JSON格式下载动画数据并实时提供给开发者。 换句话说，你也可以通过设计器直接把JSON文件放入Xcode project，让Lottie帮你下载动画。当然别误会，你还是需要为你的动画写一些代码，但是你会发现Lottie的确将为你的动画编码节省大量的时间。 Lottie现在不仅在GitHub上已经开源，而且还提供一个示例项目和一系列的示例动画，看看下面有没有你能用在iOS Apps当中示例动画吧。 Lottie 动画文件在使用Lottie之前，你需要一个以JSON文件形式输出的动画数据库。如果你已经有了一个After Effects动画，用Bodymovin插件来创建JSON文件。 如果你不会使用After Effects呢？你要如何准备你的动画？你可以雇一位设计师为你设计动画，或者你学会用After Effects。 幸运的是，这里还有一个选项，那就是：Lottie Files(能下载动画的json文件) Lottie Files是一个拥有高质量Lottie文件格式动画的网站。在这个网站，不仅设计师可以在上面陈列他们的动画而且还提供免费下载。像我一样没有After Effects使用经验的人一定会觉得这个动画库非常好用！ 在Xcode中使用Lottie如果你已经有了一个动画文件，剩下的就是准备好Xcode project。和iOS库相似地，最容易的方法就是用CocoaPods将Lottie放入Xcode 项目中。 让我们来做个演示看看Lottie是怎样工作的。 首先，启动Xcode并用Single View Application范本创建一个新项目，把新项目命名为LottieDemo（或任意你喜欢的名字）并保存。 用CocoaPods安装Lottie动画库当你创建完项目，离开Xcode，打开Terminal。我们将为安装Lottie动画库创建一个Podfile。我想你应该已经有一些使用CocoaPods的经验并且已经把它安装在你的电脑中了。 在terminal中运行下列指令来创建一个Podfile。 1234567target &apos;LottieDemo&apos; do # Comment the next line if you&apos;re not using Swift and don&apos;t want to use dynamic frameworks use_frameworks! # Pods for LottieDemo pod &apos;lottie-ios&apos;end 添加Animation JSON Files如果你用自己的动画文件对Lottie进行测试最好，但没有也没关系，从lottiefiles.com下载这个JSON格式的免费文件，我们将用这个文件做个快速的演示。 现在把JSON文件 (servishero_loading.json)拖入Xcode项目的工程管理器，把它放入LottieDemo小组。 创建多动画视图现在来到有趣的部分了，你将用不到10行代码就能执行这个示例动画。 打开ViewController.swift，然后加入一行代码将Lottie 动画库输入进去： 1import Lottie 接下来更新viewDidLoad()如下： 1234567891011121314override func viewDidLoad() &#123; super.viewDidLoad() if let animationView = LOTAnimationView(name: &quot;servishero_loading&quot;) &#123; animationView.frame = CGRect(x: 0, y: 0, width: 400, height: 400) animationView.center = self.view.center animationView.contentMode = .scaleAspectFill view.addSubview(animationView) animationView.play() &#125; &#125; 上面就是你播放动画需要的代码。在Lottie中有个LOTAnimationView分类可以直接从JSON文件下载动画数据。你要先用你已经下载好的JSON文件创建一个LOTAnimationView对象，你才能展示这个动画。 LOTAnimationView是UIView的一个子分类，所以你只要像执行其他视图一样执行LOTAnimationView就可以了。我们先将它的大小重置，放在中心位置，把内容模式设为Aspect Fill；然后我们调用addSubview把动画视图添加到主视图；最后，我们调用play()播放动画。 循环动画默认情况下，动画只播放一次。如果你想循环播放动画，你可以把loopAnimation属性设为true如下： 1animationView.loopAnimation = true LOTAnimationView 分类也为你自定义动画提供了大量属性。如果你想放慢动画播放速度，只要像下面这样改变animationSpeed属性就行了： 1animationView.animationSpeed = 0.5 从远程服务器上载入Animation JSON File你不仅可以把JSON文件保存在本地，而且可以把动画数据保存在远程服务器上。Lottie已经为开发者从远程URL上下载JSON文件准备好了API。用下面的代码替换animationView的初始化界面，看看你会得到什么样的动画。 1let animationView = LOTAnimationView(contentsOf: URL(string: &quot;https://github.com/airbnb/lottie-ios/raw/master/Example/Assets/PinJump.json&quot;)!) 动画视图转换LOTAnimationView和UIView一样都支持不同类型的动画转换。你可以通过合理地设置转换属性对动画进行旋转，大小重置，位置重置。下面是一个把动画顺时针转换45度的转换示例： 12let rotateTransform = CGAffineTransform(rotationAngle: 45.0)animationView.transform = rotateTransform 似的，你可以像其他标准UIView对象一样把UIView动画覆盖在原来的动画上。我们在现有的动画上重建一不同大小的动画。用下面的代码把viewDidLoad()替换掉： 123456789101112131415161718192021222324override func viewDidLoad() &#123; super.viewDidLoad() if let animationView = LOTAnimationView(name: &quot;servishero_loading&quot;) &#123; animationView.frame = CGRect(x: 0, y: 0, width: 400, height: 400) animationView.center = self.view.center animationView.loopAnimation = true animationView.contentMode = .scaleAspectFill animationView.animationSpeed = 0.5 // Applying UIView animation let minimizeTransform = CGAffineTransform(scaleX: 0.1, y: 0.1) animationView.transform = minimizeTransform UIView.animate(withDuration: 3.0, delay: 0.0, options: [.repeat, .autoreverse], animations: &#123; animationView.transform = CGAffineTransform.identity &#125;, completion: nil) view.addSubview(animationView) animationView.play() &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之GCD多线程]]></title>
      <url>%2F2017%2F05%2F04%2FiOS%E4%B9%8BGCD%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[多线程之GCD多线程是在一部处理耗时的任务,在主线程更新UI最简单的GCD的用法,GCD会自动根据任务在多核处理器上分配资源，优化程序。 常用的方法dispatch_async123456dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 耗时的操作 dispatch_async(dispatch_get_main_queue(), ^&#123; // 更新界面 &#125;); &#125;); dispatch_group_async的使用dispatch_group_async可以实现监听一组任务是否完成，完成后得到通知执行其他的操作。这个方法很有用，比如你执行三个下载任务，当三个任务都下载完成后你才通知界面说完成的了。下面是一段例子代码： 123456789101112131415161718dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;group1&quot;); &#125;); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;group2&quot;); &#125;); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:3]; NSLog(@&quot;group3&quot;); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;updateUi&quot;); &#125;); dispatch_release(group); dispatch_group_async是异步的方法，运行后可以看到打印结果： 123456gcdTest[43328:11303] group1gcdTest[43328:12a1b] group2gcdTest[43328:13003] group3gcdTest[43328:f803] updateUi每个一秒打印一个，当第三个任务执行后，upadteUi被打印。 dispatch_barrier_async的使用dispatch_barrier_async是在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行 123456789101112131415161718dispatch_queue_t queue = dispatch_queue_create(&quot;gcdtest.rongfzh.yc&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;dispatch_async1&quot;); &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:4]; NSLog(@&quot;dispatch_async2&quot;); &#125;); dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;dispatch_barrier_async&quot;); [NSThread sleepForTimeInterval:4]; &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;dispatch_async3&quot;); &#125;); 打印结果： 1234567gcdTest[45547:11203] dispatch_async1gcdTest[45547:11303] dispatch_async2gcdTest[45547:11303] dispatch_barrier_asyncgcdTest[45547:11303] dispatch_async3 dispatch_apply执行某个代码片段N次 1234dispatch_apply(5, globalQ, ^(size_t index) &#123; // 执行5次&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOSUI调试神器Reveal]]></title>
      <url>%2F2017%2F05%2F02%2FiOSUI%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8Reveal%2F</url>
      <content type="text"><![CDATA[CocoaPods集成Revealfile:///Applications/Reveal.app/Contents/SharedSupport/Documentation/Reveal%20Integration%20Guide.html我们保留一个CocoaPods Podspec，将Reveal集成到您的Xcode项目中。 我们的说明假设您已经将您的项目或工作区配置为与CocoaPod一起使用 - 如果没有，请现在就这样做。 警告：切勿运送与Reveal Server框架链接的产品。下面的Podfile示例将仅将Reveal Server框架链接到使用“Debug”配置编译的应用程序的构建。 将以下内容添加到您的Podfile中： 123target &apos;YourMainAppTargetName&apos; do pod &apos;Reveal-SDK&apos;, :configurations =&gt; [&apos;Debug&apos;]end 该:configurations参数确保只有将Reveal链接到您的调试版本中。 运行pod install在您的项目目录中（或者pod update Reveal-SDK如果您以前在项目中使用了CocoaPods）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac设置环境变量]]></title>
      <url>%2F2017%2F05%2F02%2FMac%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
      <content type="text"><![CDATA[环境变量在~/.bash_profile 中的 1234export PATH=$PATH:/usr/local/apache-tomcat-7.0.72/binexport M2_HOME=/usr/local/maven/apache-maven-3.5.0export PATH=$PATH:$M2_HOME/binexport PATH=$PATH:/Users/winsion/Music/MyHexoBlog/folder]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac显示隐藏文件]]></title>
      <url>%2F2017%2F05%2F02%2FMac%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[显示隐藏文件只要打开终端（位于应用程序——实用工具），将以下代码复制进去然后回车 1defaults write com.apple.finder AppleShowAllFiles -bool YES Finder需要重启才能应用修改，在终端中接着输入 1killall Finder 并回车 恢复隐藏不可见，在终端中输入以下代码并回车 1defaults write com.apple.finder AppleShowAllFiles -bool NO 同样Finder需要重启 1killall Finder]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub上Top100的Objective-C项目]]></title>
      <url>%2F2017%2F05%2F02%2FGitHub%E4%B8%8ATop100%E7%9A%84Objective-C%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[iOS开发必读-GitHub 上Top100 的 Objective-C 项目 AFNetworking 作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest GPUImage 一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 SO上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果 SDWebImage 作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单 RestKit 主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上 ReactiveCocoa 由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 “An open source project that exemplifies this brave new era for Objective-C”, 也有人说它是 Cocoa 的未来, 具体可看唐巧写的这篇 文章 three20 由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 PR 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 Nimbus , 算是 three20 的一个替代品 MBProgressHUD 作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师, 此项目是一款提示框第三方库, 帮助开发者快速应用到项目中) MagicalRecord 作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作 FMDB 一个对 SQLite 进行封装的库, 使用起来方便, 简单 Mantle 作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了. FlatUIKit 收集了很多扁平化 UI 的 iOS 组件, 方便使用 ASIHTTPRequest 一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代) FastImageCache Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点 Masonry 一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备 Shimmer Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单 SVProgressHUD 又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用 Slate 一款窗口管理应用程序, 但在两年前就已经停止更新了 JSONKit 主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了 Nimbus 作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全 CocoaLumberjack 这是 Mac 和 iOS 的一款强大的日志框架, 配置简单, 多线程, 提供更高级的 log 功能, 可用于代替默认的 NSLog 语句 Facebook SDK for iOS Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面 AsyncDisplayKit Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎 Alcatraz Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传 ViewDeck 一款开源的 iOS 活动面板组件, 还原 Path 2.0 的侧滑效果, 作者因为时间关系在两年前停止对其更新 JSQMessagesViewController 优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高 FLEX 这是 Flipboard 官方发布的一组专门用于 iOS 开发的应用内调试工具, 开发者无需将其连接到 LLDB/Xcode 或其他远程调试服务器,支持直接在 App 中运行 Xctool 是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, Travis CI , OCLint 等测试工具 OpenEmu 超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错 iCarousel 作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果 RESideMenu 作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8 321 PNChart 作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱 31.2 PonyDebugger 由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试 JVFloatLabeledTextField 作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本 SWTableViewCell UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮 AwesomeMenu 作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果 Reachability Reachablity 是用于检测 iOS 设备网络环境的库 VVDocumenter-Xcode 作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞 The Physical Web 由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段 NewsBlur 作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码 Cocos2D-SpriteBuilder 一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift, 目前该项目在 GitHub 上更新较为频繁 TTTAttributedLabel UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能 CocoaAsyncSocket 一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师 TapkuLibrary 作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中 Canvas 无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手 SocketRocket Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱 ECSlidingViewController 一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工 Json Framework 用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了 Tweaks Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了 realm-cocoa Realm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库 BlocksKit 一个开源的与 Cocoa 紧密集合的基础性框架 Appirater 一款用于提醒用户给你的 App 打分的工具 KIF Square 出品的一个开源的用户界面测试框架, 极大的简化了 iOS 开发者的 UI 测试流程 SlackTextViewController Slack 推出的一款具有文字输入框高度自适应, 自动输入, 复制单元格内容等功能的解决方案 JazzHands IFTTT 开源的一个简单易用的关键帧基础动画框架, 可通过手势、scroll views, KVO, ReactiveCocoa 等方式来控制动画 Bolts-iOS Bolts 是一个 Parse 和 Facebook 在内部使用的底层库, 方便移动开发 Spectacle 一款易用的 OS X 窗口分屏操作快捷键工具, 这是其源代码 nui 方便样式化 iOS 应用中的 UI 元素, 可在短时间内样式化整个应用, 类 CSS 原理 Induction Induction 是一款用于理解数据关系的管理工具, 这是其程序代码 JSONModel 一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换 DTCoreText 一个开源的 iOS 富文本组件, 它可以解析 HTML 与 CSS 并最终用 CoreText 绘制出来, 通常用于在一些需要显示富文本的场景下代替低性能的 UIWebView Popping 基于 Facebook Pop 引擎的 iOS 动画库, 集合了很多动画效果 TSMessages 一个用来弹出显示警告和通知的轻量级库, 样式丰富, 简单易用 KVOController 一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一 MWPhotoBrowser 一款简单的 iOS 照片浏览控件 MMDrawerController 一个轻量级, 易于使用的侧边抽屉导航 iOS 控件 QuickDialog 用于快速创建复杂的 iOS 表单, 自定义了 UITableViewCell, TableView 的样式 SVPullToRefresh 一款只需一行代码便可集成上拉刷新和下拉加载的组件 cheddar-ios Cheddar 是一款简单易用的日程管理软件, 这是其早期版本的开源代码, 该项目已停止维护 XVim 一款在 Xcode 上实现了 Vim 功能的插件 EGOTableViewPullRefresh 一款提供下拉刷新的控件, 最后更新时间是一年前 iOS-boilerplate iOS 应用程序的基础模板, 使用该模板可以省掉许多项目初始编码的工作, 内置非常多丰富的功能, 现已经停止维护 JASidePanels 一个 UIViewController 容器, 灵感来自 Facebook 和 Path 2.0 应用的菜单, 实现了左右侧滑的操作 FormatterKit 收集了很多构思优秀的 NSFormatter 子类 MSDynamicsDrawerViewController 实现了具有动态弹性效果的抽屉式侧边导航栏, 效果丰富, 可定制性强 idev-recipes iDevRecipes 博客的代码, 演示如何实现一些有趣的控件, 该项目在两年前(2013)停止了更新 XMPPFramework 一个基于 RFC-3920 实现, 支持多线程和线程保护, 同时通用于所有的 iOS 和 Mac OS 开发设备的通信框架. MacGap1 一款可以将 HTML/CSS/JS 网络应用打包成原生 Mac App 的工具 FXBlurView iOS 模糊背景类库, 可以方便的根据底层显示的状态生成模糊效果 iOS7-Sampler 整合演示了多个具有 iOS7 新特性的的项目, 提供了非常多的例子参考 PromiseKit 提供强大的 iOS 开发异步功能, 是 Promises 的实现, 受到广大开发者的追捧 Origami 此为 Facebook 推出的 Quartz Composer 的一个开源插件, 由其设计团队花费了 9 个月打造而成, 目的是为方便设计师快速构建原型, 以零代码完成复杂动画的合成和测试, 堪称神器 NSLogger 一款强大的日志分析工具, 具有大窗口查看 Log, 自定义日志等级等功能 KSImageNamed-Xcode 一款对 UIImage 的 imageNamed 提供自动补全功能的插件, 非常方便 PureLayout 一个简单却强大的 AutoLayout API 库, 兼容了 Objective-C 和 Swift, 扩展了 UIView/NSView, NSArray, 和 NSLayoutConstraint AppleDoc 一款 Objective-C 文档生成工具, 生成的文档风格保持与 Apple 官方的一致, 极大的方便了 Xcode 识别自己写的 API 文档, 安装也是十分的简单 iTerm2 iTerm2 被不少程序员称赞为 Mac 下最好用的终端, 这是其源代码, 配合 oh-my-zsh 使用效果更佳 Kiwi 一个行为驱动开发测试框架, 适用于 iOS 平台, 旨在为开发者提供一个简单配置便可使用的 BDD 库 terminal-notifier 一款命令行工具, 用来给 Mac OS X 用户发送通知 MacDown Mac OS X 下的一款开源的 Markdown 编辑器, 创意来自与 Mou, 使用 brew cask 即可完成安装 TwUI Twitter 开源的一个支持硬件加速的 Mac 的 UI 框架, 最后一次的更新时间是在 3 年前(2012) PaperFold for iOS 实现了类似折纸效果的视图切换, 可从不同方向进行切换, 该项目已经许久未更新 Reader 一款开源的 iOS PDF 阅读器, 附带书签, 列纲要等功能 WebViewJavascriptBridge 一个方便使用 Objective-C 与 JavaScript 进行通信的第三方库, 支持消息发送, 接收, 消息处理器的注册与调用以及设置消息处理的回调 iOS8-Sampler iOSX-Sampler 系列之一, 整合演示了多个具有 iOS8 新特性的的项目, 提供了非常多的例子参考 CocoaHTTPServer 一个用于 Mac OS X 或 iOS 应用的轻量级、可嵌入的HTTP 服务器框架, 方便开发者在应用中嵌入一个 HTTP 服务器 Kod Mac OS X 上一款专为程序员打造的编辑器, 这是其开源代码, 可惜的是作者在 2011 年停止了维护 TPKeyboardAvoiding 下拉键盘在 iOS 移动文本字段的通用解决方案, 能够自动处理键盘弹出后出现遮挡到文本输入框的问题 MKNetworkKit 一个轻量级网络请求框架, 完全基于 ARC, 仅有两个类, 具有自主操作多个网络请求, 更加准确的显示网络活动指标等优点 PKRevealController 一个 iOS 平台上的视图控制器集合, 通过展现多个视图控制器来进行控制器之间的切换. 设置简单, 高度灵活 AQGridView 一个命令行工具, 通过项目里的.xcdatamodel文件, 可以为每个 entity 生成两个类, 方便 CoreData 的使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cocoapods私有库]]></title>
      <url>%2F2017%2F05%2F02%2FCocoapods%E7%A7%81%E6%9C%89%E5%BA%93%2F</url>
      <content type="text"><![CDATA[CocoaPods的使用方法简单使用pod init//编辑podFile文件内容,添加框架名称pod ‘BaiduMapKit’//执行安装命令pod install –no-repo-update 导入百度地图导航pod ‘BaiduNaviSDK-iOS’, ‘~&gt; 3.1.1’ ReactiveCocoa发布了重大的更新，所以如果想使用最新版本的框架，我们需要注意一下问题。 高级使用 如果你只是纯 swift 项目，你继续使用 ReactiveCocoa 。但是 RAC 依赖于 ReactiveSwift ，等于你引入了两个库。这种情况下的podfile的文件如下: 1234use_frameworks! target &apos;Target名称&apos; do pod &apos;ReactiveCocoa&apos;, &apos;5.0.0-alpha.3&apos;end 如果你的项目是纯 OC 项目，你需要使用的是 ReactiveObjC 。这个库里面包含原来 RAC 2 的全部代码。这种情况下的podfile的文件如下: 1234use_frameworks! target &apos;Target名称&apos; do pod &apos;ReactiveObjC&apos;, &apos;~&gt; 2.1.0&apos;end 如果你的项目是 Swift 和 OC 混编，你需要同时引用ReactiveCocoa 和 ReactiveObjCBridge 。但是 ReactiveObjCBridge 依赖于 ReactiveObjC ，所以你就等于引入了 4 个库。其中，ReactiveObjCBridge暂不支持cocoapods导入，需要手动导入！！这种情况下的podfile的文件如下（注意，ReactiveObjCBridge手动导入就好啦）: 12345use_frameworks! target &apos;Target名称&apos; do pod &apos;ReactiveObjC&apos;, &apos;~&gt; 2.1.0&apos; pod &apos;ReactiveCocoa&apos;, &apos;5.0.0-alpha.3&apos;end 创建描述文件创建一个文件 podspec创建一个 podspec 索引库信息pod repo 查看本地索引创建本地索引库 1pod repo add WZCPrivate https://git.codingnet.WZCPrivate.git pod repo push 库的名字 库名.podspecpush 到私有索引库 创建仓库工程模板 pod lib create XXXLib 添加需要的库文件到相应文件夹 关联远程库 git remote add origin 远程仓库地址 打标签, 并提交到远程仓库 1$ git tag -m &quot;初始版本&quot; &quot;0.1.0&quot; 1$ git push --tags #推送tag到远程仓库 验证podspec文件1pod lib lint 向私有的Spec Repo中提交podspec1pod repo push SpecName XXX.podspec 使用pod库12source &apos;git@git.coding.net:wangshunzi/XMGFMSpecs.git&apos;source &apos;https://github.com/CocoaPods/Specs.git&apos; #官方仓库的地址 1pod &apos;XXXLib/XXXSub&apos; 远程私有库依赖问题 在 项目名.podspec 中添加组件依赖 1network.dependency &apos;AFNetworking&apos; 优化创建子库 需要啥用啥]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux的终端操作]]></title>
      <url>%2F2017%2F05%2F02%2FLinux%E7%9A%84%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[终端的基本操作 通过远程工具登陆到linux后，所在的位置是当前登录用户的家目录(home directory)。 家目录的符号用~表示。 linux的文件系统是一个树结构。linux文件系统的树根成为根目录，使用符号”/“表示。linux文件系统中使用符号”..”表示上级目录。linux文件系统中使用符号”.”表示当前目录。linux文件系统中，如果文件使用“.”开头，就表示隐藏文件linux的路径表示方式有两种，一种是绝对路径(以”/“开头的路径)，一种是相对路径 命令cd(change directory)：跳转到其他目录 命令ls：查看目录下包含什么东西 ls -l：显示详细信息 ls -a：显示隐藏文件 命令pwd：显示当前所处位置的 命令clear：清屏//权限 命令mkdir：创建文件夹 mkdir -p ：递归创建上级文件夹 命令touch：创建空白文件 命令more：查看 内容 命令rm：删除文件命令rmdir：删除文件夹命令rm -rf:删除文件(夹)，不论层级多深，一概删除，并且不给出提示 命令cp(copy)：复制文件，还有一个功能是创建新文件 命令mv(move): 移动文件，还有个功能是重命名 VI操作： 当使用命令vi f1回车时，进入了vi编辑器内，处于只读状态(只能看不能写)； 按字母”i“(insert)或者”a“(append)就可以进入编辑状态； 按键盘上的”Esc“键，再按Shift+:，进入命令状态 如果输入命令wq，意味着保存退出； 如果输入命令q！，意味着不保存退出； linux的权限使用9位字符表示，rwx rwx rwx这里面r表示读权限，w表示写权限，x表示执行权限，-表示没有权限 这9位字符，每3位一组，分为3组。第一组表示创建者的权限；第二组表示创建者所在组的权限；第三组表示其他人的权限； 权限还可以使用数字表示。rwx用数字表示为4+2+1=7。新创建文件的默认权限是644；新创建文件夹的默认权限是755. 命令chmod：修改权限，三个组分别使用u、g、o表示，赋权限使用“+”，去掉权限使用“-”。 chmod u+x f1 //表示文件f1的创建者增加执行权限 chmod o-r f1 //表示文件f1的其他人去掉读权限]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[B客户orC用户]]></title>
      <url>%2F2017%2F05%2F02%2FB%E5%AE%A2%E6%88%B7orC%E7%94%A8%E6%88%B7%2F</url>
      <content type="text"><![CDATA[to B or to Cwhat12C:普通对象（customer）B:商业模式（business） 区别客户与用户 1客户是理性的，用户则偏感性 工具与玩具 1客户关心的是ROI（投入产出比），用户要的就是玩的爽（满足了人性的某个弱点） 卖艺与卖身 1客户有大小之分，用户则基本一样]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java注意事项]]></title>
      <url>%2F2017%2F05%2F02%2Fjava%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[二进制计算处理误差问题java中提供了BigDecimal这个超大的类，用来存储浮点型，使用它可以处理二进制误差问题bigdecimal 1234public void Demo1()&#123; BigDecimal b1=new BigDecimal(2.0+&quot;&quot;);//注意：只能使用String类型的构造 System.out.println(b1.subtract(new BigDecimal(1.1+&quot;&quot;)));//0.9 &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql最常用的语法]]></title>
      <url>%2F2017%2F05%2F02%2FMysql%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[MySQL的基本语法left JOIN 左表匹配右表 有没有内容全部匹配 12345SELECT Persons.LastName, Orders.OrderNoFROM PersonsINNER JOIN OrdersON Persons.Id_P=Orders.Id_PORDER BY Persons.LastName 只输出右边的表有内容的 12345SELECT Persons.LastName, Persons.FirstName, Orders.OrderNoFROM PersonsINNER JOIN OrdersON Persons.Id_P=Orders.Id_PORDER BY Persons.LastName RIGHT JOIN 关键字会右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1) 中没有匹配的行。1234SELECT column_name(s)FROM table_name1RIGHT JOIN table_name2 ON table_name1.column_name=table_name2.column_name SQL FULL JOIN 关键字只要其中某个表存在匹配，FULL JOIN 关键字就会返回行。1234SELECT column_name(s)FROM table_name1FULL JOIN table_name2 ON table_name1.column_name=table_name2.column_name UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 123SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2 删除表1drop table `MYFirstTable` 删除数据库1drop database MY_db 复制表1creat table `NewMYFirstTable` select *from `OldMYFirstTable` 修改数据库的编码规则1alter database mydb character set utf8; 创建数据库的时候设置编码规则1CREATE DATABASE db_name DEFAULT CHARACTER SET utf8 创建表&lt;加约束)1234567891011CREATE TABLE Persons(Id_P int NOT NULL,(不接受空值)LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)UNIQUE (Id_P) **约束**PRIMARY KEY (Id_P) **设置主键**) 123SQL UNIQUE 约束UNIQUE 约束唯一标识数据库表中的每条记录。UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。 PRIMARY KEY 约束唯一标识数据库表中的每条记录。主键必须包含唯一的值。主键列不能包含 NULL 值。每个表都应该有一个主键，并且每个表只能有一个主键。 如果表已经存在,择设置主键 12ALTER TABLE PersonsADD PRIMARY KEY (Id_P) 撤销主键约束 12ALTER TABLE PersonsDROP PRIMARY KEY CHECK 约束规定 “Id_P” 列必须只包含大于 0 的整数 1CHECK (Id_P&gt;0) 更新一个数值 1update setUpdefault set neme = &apos;hahhahfrewgerwg&apos; WHERE neme = &apos;hahhah&apos; 创建索引 CREATE INDEX 语句用于在表中创建索引。在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。 注释：更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。 12CREATE INDEX index_nameON table_name (column_name) 删除索引 1DROP INDEX index_name ON table_name 删除表的数据12345TRUNCATE TABLE 表名称delete from tableName//删除部分数据DELETE FROM table1 WHERE ...; 添加列,删除列,改变列的数据类型123456789101112如需在表中添加列，请使用下列语法:ALTER TABLE table_nameADD column_name datatype要删除表中的列，请使用下列语法：ALTER TABLE table_name DROP COLUMN column_name要改变表中列的数据类型，请使用下列语法：ALTER TABLE table_nameALTER COLUMN column_name datatype //设置让主键自增我们通常希望在每次插入新记录时，自动地创建主键字段的值。我们可以在表中创建一个 auto-increment 字段。下列 SQL 语句把 “Persons” 表中的 “P_Id” 列定义为 auto-increment 主键： 1alter table S_Province modify `ProvinceID` integer auto_increment 添加视图123456CREATE VIEW [Current Product List] ASSELECT ProductID,ProductNameFROM ProductsWHERE Discontinued=No我们可以查询上面这个视图：SELECT * FROM [Current Product List] 12 时间的格式12345MySQL 使用下列数据类型在数据库中存储日期或日期/时间值：DATE - 格式 YYYY-MM-DDDATETIME - 格式: YYYY-MM-DD HH:MM:SSTIMESTAMP - 格式: YYYY-MM-DD HH:MM:SSYEAR - 格式 YYYY 或 YY 1SELECT * FROM Orders WHERE OrderDate=&apos;2008-12-26&apos; NULL值我们如何仅仅选取在 “Address” 列中带有 NULL 值的记录呢？我们必须使用 IS NULL 操作符： 12SELECT LastName,FirstName,Address FROM PersonsWHERE Address IS NULL 数据类型 从第几行哦第几行limit 2， 4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[程序员最正确的定义]]></title>
      <url>%2F2017%2F04%2F28%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%80%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
      <content type="text"><![CDATA[程序员最正确的定义##对这个世界抱有永不穷尽的好奇心，持续学习的人才是程序员; ##自己组装电脑，选硬件，帮妹纸装系统，杀毒，修电灯泡，工作上用脚本提升效率，做UI，写业务，造轮子，搭架构等等，这些都是程序员的领地; ##对编程持有源源不绝的动力和激情，在新事物的接纳和学习上敢为人先者，这才是程序员。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之YYkit框架学习]]></title>
      <url>%2F2017%2F04%2F27%2FiOS%E4%B9%8BYYkit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[iOS之YYkit框架学习YYKit 是一组庞大、功能丰富的 iOS 组件。为了尽量复用代码，这个项目中的某些组件之间有比较强的依赖关系。为了方便其他开发者使用，我从中拆分出以下独立组件： YYModel — 高性能的 iOS JSON 模型框架 YYCache — 高性能的 iOS 缓存框架。YYImage— 功能强大的 iOS 图像框架。YYWebImage — 高性能的 iOS 异步图像加载框架。YYText — 功能强大的 iOS 富文本框架。YYKeyboardManager — iOS 键盘监听管理工具。YYDispatchQueuePool — iOS 全局并发队列管理工具。YYAsyncLayer — iOS 异步绘制与显示的工具。YYCategories — 功能丰富的 Category 类型工具库。 YYModel的学习 高性能: 模型转换性能接近手写解析代码。自动类型转换: 对象类型可以自动转换，详情见下方表格。类型安全: 转换过程中，所有的数据类型都会被检测一遍，以保证类型安全，避免崩溃问题。无侵入性: 模型无需继承自其他基类。轻量: 该框架只有 5 个文件 (包括.h文件)。文档和单元测试: 文档覆盖率100%, 代码覆盖率99.6%。 常用的方法: 123456789101112131415161718# json转模型+ (instancetype)yy_modelWithJSON:(id)json;# 模型转字符串- (NSString *)yy_modelToJSONString # 字典转模型+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary ;# 声明数组、字典或者集合里的元素类型时要重写+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelContainerPropertyGenericClass；# 字典里的key值与模型的属性值不一致要重复+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelCustomPropertyMapper;# 下面两者是属性值在两个dic与模型之间的转化方法（自己看代码吧~😂）- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic ；- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic； YYCache的学习 基本介绍 YYCache由YYCache，YYDiskCache，YYMemoryCache和YYKVStorage组成，其中YYKVStorage可直接对sqlite和文件系统进行读写（YYDiskCache的底层实现）; YYCache 如果不指定存储方式，默认存入内存的时候同时写入磁盘从内存中读，有就直接拿来用; 2.没有再从磁盘读，有就拿来用，并写入内存中; 3.仍然没有就返空和指定存储方式一样 YYMemoryCache 将对象存储在内存中存取速度较快短（下次重新启动运用的时候缓存会被清空） YYDiskCache 将对象存储在磁盘中[1]存取速度较慢长（下次重新启动运用的时候缓存仍然存在） 主要api的使用: 12345678910111213141516# 创建YYCache对象(如果有很多对象都对应同一个文件夹，会导致缓存不稳定) @param name 缓存文件夹的名称，一旦被创建我们就不应该对这个文件夹进行读写了(也就是我们应该 用YYCache操作这个文件夹)+ (nullable instancetype)cacheWithName:(NSString *)name;# 判断是否缓存中`key`是否存在- (BOOL)containsObjectForKey:(NSString *)key;# 返回`key`对应的对象- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;# 设置`key`对应的对象- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;# 移除`key`对应的对象- (void)removeObjectForKey:(NSString *)key; 3.封装了一个网络请求累具体思想是: 1234* 1.先加载缓存* 2.判断有没有网络* 3.如果没有网络则return* 4.有网，则继续请求，然后刷新内容，刷新缓存 具体实现:见我的github,欢迎starhttps://github.com/321zhangyang/SPHttpWithYYCache 1234567891011添加 WZCHttp文件到你的工程;需要添加 pod &apos;AFNetworking&apos; pod &apos;YYCache&apos; 两个框架网络请求就比较简单了类方法:[WZCHttp postRequestUrl....][WZCHttp getRequestUrl....]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之谓词NSPredicate的应用]]></title>
      <url>%2F2017%2F04%2F25%2FiOS%E4%B9%8B%E8%B0%93%E8%AF%8DNSPredicate%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[iOS之谓词NSPredicate的应用说到谓词，我们先来看一下谓词的语法。 比较运算符 &gt;:大于 &lt;:小于 &gt;=:大于等于 &lt;=:小于等于 =,==:等于 !=,&lt;&gt;:不等于 逻辑运算符 and /&amp;&amp;和 or/||或 not/!非 关系运算符 ANY任意，SOME 一些 ALL所有元素 NONE没有元素 等同于not any in包含 范围运算符 between 如，1 BETWEEN { 0 , 33 }，或者$INPUT BETWEEN { $LOWER, $UPPER }。 in包含 字符串本身 SELF 如：@“self＝＝‘APPLEIOS’” 字符串相关 contain between endswith like通配符 like 如:@”name like[cd] ‘ios‘“ @&quot;name&quot; like[cd] &apos;ios*&apos;&quot; 正则表达式matches 如：NSString *regex = @”^A.+e$”; //以A开头，e结尾 @”name MATCHES %@”,regex 数组操作 array[index]：指定数组中特定索引处的元素。 array[first]:制定第一个元素 array[last]:制定最后一个元素 array[size]:制定数组大小 下面我们再来看一下具体的事例： 新建一个项目，然后添加类products 1.Products.h 123456789#import &lt;Foundation/Foundation.h&gt;@interface Products : NSObject@property NSString *productName;@property NSInteger productCount;@property NSString *productImageUrl;+(id)initProductWithName:(NSString *) name withCount:(NSInteger) count withImage:(NSString *) imageurl;@end 2.Products.m 1234567891011121314151617#import &quot;Products.h&quot;@implementation Products+(id)initProductWithName:(NSString *)name withCount:(NSInteger)count withImage:(NSString *)imageurl&#123; Products *sprducts=[[Products alloc] init]; sprducts.productName=name; sprducts.productCount=count; sprducts.productImageUrl=imageurl; return sprducts;&#125;-(NSString *)description&#123; NSString *str=[NSString stringWithFormat:@&quot;产品名称：%@，数量：%ld，图片：%@&quot;,_productName,_productCount,_productImageUrl]; return str;&#125;@end 3.测试方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#import &quot;ViewController.h&quot;#import &quot;Products.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self mainTest];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning];&#125;-(void) mainTest&#123; Products *p1=[Products initProductWithName:@&quot;A苹果sdasf&quot; withCount:2 withImage:@&quot;464.jpg&quot;]; Products *p2=[Products initProductWithName:@&quot;fsdf橘子gag&quot; withCount:53 withImage:@&quot;fsdfas.jpg&quot;]; Products *p3=[Products initProductWithName:@&quot;dfgdf香蕉&quot; withCount:5 withImage:@&quot;sfas.jpg&quot;]; Products *p4=[Products initProductWithName:@&quot;三星&quot; withCount:76 withImage:@&quot;ggas.jpg&quot;]; Products *p5=[Products initProductWithName:@&quot;华为dfsd&quot; withCount:9 withImage:@&quot;gasa.jpg&quot;]; Products *p6=[Products initProductWithName:@&quot;微软dhnnne&quot; withCount:6 withImage:@&quot;hshhh.jpg&quot;]; Products *p7=[Products initProductWithName:@&quot;三星&quot; withCount:6 withImage:@&quot;hshhh.jpg&quot;]; Products *p8=[Products initProductWithName:@&quot;15300250500&quot; withCount:6 withImage:@&quot;hshhh.jpg&quot;]; NSArray *sproducts=[NSArray arrayWithObjects:p1,p2,p3,p4,p5,p6,p7,nil]; //数量小于9 定义谓词 包含过滤条件 NSPredicate *prdicate=[NSPredicate predicateWithFormat:@&quot;productCount&lt;%d&quot;,9]; //过滤结果返回新的数组 NSArray *newArray=[sproducts filteredArrayUsingPredicate:prdicate]; for (Products *item in newArray) &#123; NSLog(@&quot;newArray=%@&quot;,item.productName); &#125; //数量大于9 并且productname等于“三星jfggg” 定义谓词 包含过滤条件 prdicate=[NSPredicate predicateWithFormat:@&quot;productName=&apos;三星&apos; &amp;&amp; productCount&gt;9&quot;]; //过滤结果返回新的数组 newArray=[sproducts filteredArrayUsingPredicate:prdicate]; for (Products *item in newArray) &#123; NSLog(@&quot;newArray=%@&quot;,item.productName); &#125; //in(包含) *注意 包含是全字匹配 prdicate = [NSPredicate predicateWithFormat:@&quot;productName IN &#123;&apos;g&apos;,&apos;华为&apos;,&apos;三星&apos;&#125;||productCount IN &#123;2,5&#125;&quot;]; //过滤结果返回新的数组 newArray=[sproducts filteredArrayUsingPredicate:prdicate]; for (Products *item in newArray) &#123; NSLog(@&quot;newArray=%@&quot;,item.productName); &#125; //productName以a开头的 prdicate = [NSPredicate predicateWithFormat:@&quot;productName BEGINSWITH &apos;A&apos;&quot;]; //productName以ba结尾的 prdicate = [NSPredicate predicateWithFormat:@&quot;productName ENDSWITH &apos;g&apos;&quot;]; //name中包含字符a的 prdicate = [NSPredicate predicateWithFormat:@&quot;productName CONTAINS &apos;a&apos;&quot;]; //like 匹配任意多个字符 //productName中只要有s字符就满足条件 prdicate = [NSPredicate predicateWithFormat:@&quot;productName like &apos;*s*&apos;&quot;]; //?代表一个字符，下面的查询条件是：name中第二个字符是s的 prdicate = [NSPredicate predicateWithFormat:@&quot;productName like &apos;?s*&apos;&quot;]; newArray=[sproducts filteredArrayUsingPredicate:prdicate]; for (Products *item in newArray) &#123; NSLog(@&quot;newArray=%@&quot;,item.productName); &#125; //正则表达式 验证是否是手机号 BOOL isMobileNum=[self isMobileNumber:p8.productName]; if(isMobileNum) NSLog(@&quot;是真确的手机号：%@&quot;,p8.productName); &#125;- (BOOL)isMobileNumber:(NSString *)mobileNum&#123; /** * 手机号码 * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188 * 联通：130,131,132,152,155,156,185,186 * 电信：133,1349,153,180,189 */ NSString * MOBILE = @&quot;^1(3[0-9]|5[0-35-9]|8[025-9])\\d&#123;8&#125;$&quot;; /** * 中国移动：China Mobile * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188 */ NSString * CM = @&quot;^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\\d)\\d&#123;7&#125;$&quot;; /** * 中国联通：China Unicom * 130,131,132,152,155,156,185,186 */ NSString * CU = @&quot;^1(3[0-2]|5[256]|8[56])\\d&#123;8&#125;$&quot;; /** * 中国电信：China Telecom * 133,1349,153,180,189 */ NSString * CT = @&quot;^1((33|53|8[09])[0-9]|349)\\d&#123;7&#125;$&quot;; /** * 大陆地区固话及小灵通 * 区号：010,020,021,022,023,024,025,027,028,029 * 号码：七位或八位 */ // NSString * PHS = @&quot;^0(10|2[0-5789]|\\d&#123;3&#125;)\\d&#123;7,8&#125;$&quot;; NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, MOBILE]; NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CM]; NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CU]; NSPredicate *regextestct = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CT]; if (([regextestmobile evaluateWithObject:mobileNum] == YES) || ([regextestcm evaluateWithObject:mobileNum] == YES) || ([regextestct evaluateWithObject:mobileNum] == YES) || ([regextestcu evaluateWithObject:mobileNum] == YES)) &#123; if([regextestcm evaluateWithObject:mobileNum] == YES) &#123; NSLog(@&quot;中国移动&quot;); &#125; else if([regextestct evaluateWithObject:mobileNum] == YES) &#123; NSLog(@&quot;联通&quot;); &#125; else if ([regextestcu evaluateWithObject:mobileNum] == YES) &#123; NSLog(@&quot;电信&quot;); &#125; else &#123; NSLog(@&quot;Unknow&quot;); &#125; return YES; &#125; else &#123; return NO; &#125;&#125;@end 4.正则表达式，例子是验证是否是手机号 //正则表达式串 NSString MOBILE = @”^1(3[0-9]|5[0-35-9]|8[025-9])\d{8}$”;//创建含有正则表达式的帅选器 NSPredicate regextestmobile = [NSPredicate predicateWithFormat:@”SELF MATCHES %@”, MOBILE];//筛选器的evaluateWithObject方法反向验证是否手机号，返回bool值BOOL isPhoneNum=[regextestmobile evaluateWithObject:@”15300250500”] ;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybaties的基础用法]]></title>
      <url>%2F2017%2F04%2F24%2FMybaties%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Mybaties的基础用法基础用法1.通过条件查询先创建example,添加条件 1234567TbItemExample tbItemExample = new TbItemExample(); TbItemExample.Criteria criteria = tbItemExample.createCriteria(); criteria.andIdEqualTo(id); List&lt;TbItem&gt; tbItems = tbItemMapper.selectByExample(tbItemExample); item = tbItems.get(0); 2.分页插件的基本使用 在调价查询前,加上 1PageHelper.startPage(page, rows); page是页数,rows是每页显示的条数 总页数,查询之后 12PageInfo&lt;TbItem&gt; pageInfo = new PageInfo&lt;TbItem&gt;(tbItems); **总页数** pageInfo.getTotal(); 3.基本的查询 insert delete update select 高级用法1.复杂的表结构,多表关联 在map.java中添加新的方法 在对应的XML文件中实现这个方法 1234567891011121314 1.添加对结果的映射 &lt;resultMap id=&quot;ResultMapAndItemName&quot; type=&quot;com.taotao.pojo.TbItemParam&quot; extends=&quot;BaseResultMap&quot;&gt; &lt;result column=&quot;param_data&quot; property=&quot;paramData&quot; jdbcType=&quot;LONGVARCHAR&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;itemCatName&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/resultMap&gt; **column是数据库中字段的名字,property是表中的属性的名字.type是返回结果对一个的ben** 2.实现map中的方法 &lt;select id=&quot;selectItemParamAndItemCat&quot; resultMap=&quot;ResultMapAndItemName&quot; parameterType=&quot;com.taotao.pojo.TbItemParam&quot;&gt;SELECT tb_item_param.id,item_cat_id,param_data,tb_item_param.created,tb_item_param.updated,name from tb_item_paramLEFT join tb_item_cat on tb_item_param.item_cat_id = tb_item_cat.id&lt;/select&gt;** id是实现的方法名,resultmap对应上面对返回结果的映射,parameterType是返回结果对一个的ben同上**]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[docker的基本用法]]></title>
      <url>%2F2017%2F04%2F21%2Fdocker%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[1:验证是否安装成功 1sudo docker run hello-world 2.重启 123#service docker start //启动#service docker restart //重启#service docker stop //停止 3.版本 1Docker服务对应的版本查看 4.查找镜像 1sudo docker search ubuntu/centos 5.获取镜像 1sudo docker pull ubuntu # 获取 6.查看当前安装的镜像 1sudo docker images 7.运行镜像 1sudo docker run -i -t centos /bin/bash 8.查看当前运行的容器 1sudo docker ps 9.docker help 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ sudo docker # docker 命令帮助Commands: attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像 build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像 commit Create a new image from a container&apos;s changes # 提交当前容器为新的镜像 cp Copy files/folders from the containers filesystem to the host path # 从容器中拷贝指定文件或者目录到宿主机中 create Create a new container # 创建一个新的容器，同 run，但不启动容器 diff Inspect changes on a container&apos;s filesystem # 查看 docker 容器变化 events Get real time events from the server # 从 docker 服务获取容器实时事件 exec Run a command in an existing container # 在已存在的容器上运行命令 export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ] history Show the history of an image # 展示一个镜像形成历史 images List images # 列出系统当前镜像 import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应 export] info Display system-wide information # 显示系统相关信息 inspect Return low-level information on a container # 查看容器详细信息 kill Kill a running container # kill 指定 docker 容器 load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save] login Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器 logout Log out from a Docker registry server # 从当前 Docker registry 退出 logs Fetch the logs of a container # 输出当前容器日志信息 port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端口 pause Pause all processes within a container # 暂停容器 ps List containers # 列出容器列表 pull Pull an image or a repository from the docker registry server # 从docker镜像源服务器拉取指定镜像或者库镜像 push Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker源服务器 restart Restart a running container # 重启运行的容器 rm Remove one or more containers # 移除一个或者多个容器 rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] run Run a command in a new container # 创建一个新的容器并运行一个命令 save Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 load] search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像 start Start a stopped containers # 启动容器 stop Stop a running containers # 停止容器 tag Tag an image into a repository # 给源中镜像打标签 top Lookup the running processes of a container # 查看容器中运行的进程信息 unpause Unpause a paused container # 取消暂停容器 version Show the docker version information # 查看 docker 版本号 wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值Run &apos;docker COMMAND --help&apos; for more information on a command. 10.删除镜像 12docker ps -a 获取容器namedocker rm container_name ``docker rmi xxx1234# 安装nginx1,安装安装wget yum install wget12 sudo apt-get install -y nginx```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybaties逆向工程]]></title>
      <url>%2F2017%2F04%2F21%2FMybaties%2F</url>
      <content type="text"><![CDATA[Mybaties逆向工程反编译数据库1.需要的jar包 12345log4j-1.2.16.jarmybatis-3.2.3.jarmybatis-generator-core-1.3.2.jarmysql-connector-java-5.1.28-bin.jarojdbc14.jar 2.配置的文件,配置文件的名称为 “generatorConfig.xml” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/taotao&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.taotao.pojo&quot; targetProject=&quot;./src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.taotao.mapper&quot; targetProject=&quot;./src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.taotao.mapper&quot; targetProject=&quot;./src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_content&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_content_category&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_cat&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_desc&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_param&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_param_item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_order&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_order_item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_order_shipping&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_user&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 3.逆向工程生成popo和dao持久层 public class GeneratorSqlmap { public void generator() throws Exception{ List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; //指定 逆向工程配置文件 File configFile = new File(&quot;generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); } public static void main(String[] args) throws Exception { try { GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); } catch (Exception e) { e.printStackTrace(); } } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FTP上传下载]]></title>
      <url>%2F2017%2F04%2F17%2FFTP%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[Ftp的上传和下载注意 必须加上编码格式，否则就算上传成功也是 返回fault 123ftpClient.setControlEncoding(&quot;UTF-8&quot;);ftpClient.enterLocalPassiveMode();ftpClient.setFileTransferMode(FTP.STREAM_TRANSFER_MODE); 下载也需要添加,必须在连接上ftp服务器后添加 依赖12345&lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-net.version&#125;&lt;/version&gt; //版本号&lt;/dependency&gt; 源码上传 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Description: 向FTP服务器上传文件 * * @param hostName FTP服务器hostname * @param port FTP服务器端口 * @param username FTP登录账号 * @param password FTP登录密码 * @param basePath FTP服务器基础目录 * @param filePath FTP服务器文件存放路径。例如分日期存放：/2015/01/01。文件的路径为basePath+filePath * @param fileName 上传到FTP服务器上的文件名 * @param inputStream 输入流 * @return 成功返回true，否则返回false */ public static boolean upLoadFile(String hostName, int port, String username, String password,InputStream inputStream, String basePath, String filePath, String fileName) throws IOException &#123; boolean result = false; FTPClient ftpClient = new FTPClient(); try &#123; int reply; ftpClient.connect(hostName, port); ftpClient.login(username, password); reply = ftpClient.getReplyCode(); ftpClient.setControlEncoding(&quot;UTF-8&quot;); ftpClient.enterLocalPassiveMode(); ftpClient.setFileTransferMode(FTP.STREAM_TRANSFER_MODE); if (!FTPReply.isPositiveCompletion(reply)) &#123; ftpClient.disconnect(); return result; &#125; if (!ftpClient.changeWorkingDirectory(basePath + filePath)) &#123; //创建目录 String[] dirs = filePath.split(&quot;/&quot;); String temppath = basePath; for (String dir : dirs) &#123; if (dir == null || &quot;&quot;.equals(dir)) continue; temppath += &quot;/&quot; + dir; if (!ftpClient.changeWorkingDirectory(temppath)) &#123; if (!ftpClient.makeDirectory(temppath)) &#123; return result; &#125; else &#123; ftpClient.changeWorkingDirectory(temppath); &#125; &#125; &#125; &#125; ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); if (!ftpClient.storeFile(fileName, inputStream)) &#123; return result; &#125; ftpClient.logout(); inputStream.close(); result = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ftpClient.isConnected()) &#123; try &#123; ftpClient.disconnect(); &#125; catch (IOException ioe) &#123; &#125; &#125; &#125; return result; &#125; 下载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Description: 从FTP服务器下载文件 * * @param host FTP服务器hostname * @param port FTP服务器端口 * @param username FTP登录账号 * @param password FTP登录密码 * @param remotePath FTP服务器上的相对路径 * @param fileName 要下载的文件名 * @param localPath 下载后保存到本地的路径 * @return */ public static boolean downloadFile(String host, int port, String username, String password, String remotePath, String fileName, String localPath) &#123; boolean result = false; FTPClient ftp = new FTPClient(); try &#123; int reply; ftp.connect(host, port); // 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器 ftp.login(username, password);// 登录 reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) &#123; ftp.disconnect(); return result; &#125; ftp.setControlEncoding(&quot;UTF-8&quot;); ftp.enterLocalPassiveMode(); ftp.setFileTransferMode(FTP.STREAM_TRANSFER_MODE); ftp.changeWorkingDirectory(remotePath);// 转移到FTP服务器目录 FTPFile[] fs = ftp.listFiles(); if (fs == null) return result; for (FTPFile ff : fs) &#123; if (ff.getName().equals(fileName)) &#123; File localFile = new File(localPath + &quot;/&quot; + ff.getName()); OutputStream outputStream = new FileOutputStream(localFile); String ftpPath = remotePath +&quot;/&quot; + ff.getName(); boolean res = ftp.retrieveFile(ftpPath, outputStream); outputStream.close(); if (!res) return result; break; &#125; &#125; ftp.logout(); result = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ftp.isConnected()) &#123; try &#123; ftp.disconnect(); &#125; catch (IOException ioe) &#123; &#125; &#125; &#125; return result; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx做负载均衡]]></title>
      <url>%2F2017%2F04%2F17%2Fnginx%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
      <content type="text"><![CDATA[一． Nginx简介Nginx 是一个开源的高性能的HTTP和反向代理服务器，用于实现资源缓存、web server负载均衡等功能，其特点是占有内存少，并发能力强。使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。是目前最流行的反向代理服务器之一。Nginx反向代理实现Tomcat集群服务器的负载均衡二． Tomcat简介Tomcat是一个免费的开源的纯JAVA开发的Web 应用服务器，可以充当轻量级JAVAEE项目的应用服务器，它还是一个运行Servlet和JSP的web容器。三． 为什么要配置服务器集群服务器集群：是指将很多服务器集中起来一起进行同一种服务，在客户端看来就象是只有一个服务器。 集群可以利用多个计算机进行并行计算从而获得很高的计算速度，也可以用多个计算机做备份，从而使得任何一个机器坏了整个系统还是能正常运行。集群目的：一方面，对于对于日访问量或者并发访问量十分巨大的网站来说，如果只部署一台服务性能十分低下，极有可能对暴风雨般的请求(2016年双十一天猫淘宝几十万的峰值并发请求)招架不住而随时被挂掉，对企业来造成重大损失。有必要多台服务器来分担这种并发请求的压力。另一方面，群集化操作可以减少单点故障数量，就算一台服务器出现了故障，其他服务器正常运行，保证企业的日常运作不受影响，这是非常有必要的事情。并且实现了群集化资源的高可用性。四． 负载均衡对于集群来说，负载均衡意味着当反向代理服务Nginx接受到用户发起的请求后，会把请求按照权重均分到不同的集群服务器上，尽可能让每个服武器均摊请求，减少服务器的压力，提高性能，防止由于高并发导致的服务器宕机或者瘫痪等。应用架构：Nginx反向代理实现Tomcat集群服务器的负载均衡 准备工作：说明：（1）测试环境为windows（2）由于tomcat需要jdk，因此需要安装jdk并配置环境变量（3）下载Nginx并解压(Nginx下载地址：http://nginx.org)（4）下载Tomcat (Tomcat下载地址: http://tomcat.apache.org/download-70.cgi)（5）准备使用两个tomcat服务器，一个Nginx服务器（6）同一个测试web项目(只包含一个jsp页面)打成war包，分别放在tomcat1和tomcat2的webapps目录下服务器名称 测试版本 测试IPNginx Nginx-1.11.13 127.0.0.1:80(默认端口)Tomcat1 7.0+ 127.0.0.1:8080Tomcat2 7.0+ 127.0.0.1:8090主要内容一．搭建Nginx服务器将下载好的Nginx服务器压缩包放到任意盘（比如D盘）进行解压，解压后目录结构为：图（1）Nginx反向代理实现Tomcat集群服务器的负载均衡 成功。此时：在浏览器中输入本机环回地址测试：http://127.0.0.1若出现图（2）,则说明nginx启动成功，服务器正常运行。Nginx反向代理实现Tomcat集群服务器的负载均衡 注意：由于nginx的默认端口为80，因此要确保本机没有其他应用程序占用该端口。至此我们可以进行下一步工作一．搭建Tomcat服务器在搭建Tomcat服务器前，首先需要在安装jdk，因为Tomcat是java写的，而java运行需要jdk。该步骤不是本文讨论的重点，略去。安装好jdk后，需要将Tomcat服务器压缩文件解压两份，分别取名为Tomcat1和Tomcat2。如图（3）tomcat集群服务器所示：Nginx反向代理实现Tomcat集群服务器的负载均衡 在真实环境中，该服务器可以安装到不同的主机中。其中每个服务器目录结构为：图（4）Nginx反向代理实现Tomcat集群服务器的负载均衡 在图（4）的Conf文件夹下面的配置文件server.xml需要将两个tomcat服务的端口改为本机唯一。（若是不同主机则不用修改，默认端口为8080）将tomcat1的server.xml中的服务端口，连接器端口不动（默认）将tomcat2的server.xml中的服务端口改为8006，连接器端口改为依次8090，8010修改server.xml的文件位置为第22行，第70行，第91行：修改后的效果图（5）为：Nginx反向代理实现Tomcat集群服务器的负载均衡 Nginx反向代理实现Tomcat集群服务器的负载均衡 以上步骤完成即可进行下一步一．准备测试项目准备同一个测试web项目，该项目只有一个index.jsp文件。只是在该文件中写一段分别代表两个不同服务器的文字，以示区别：在准备放入tomcat1的项目的index.jsp中写入：“这是四川展谊科技，我部署在tomcat1中！”在准备放入tomcat2的项目的index.jsp中写入：“这是四川展谊科技，我部署在tomcat2中！”每个项目的目录内部结构为：图（6）所示：Nginx反向代理实现Tomcat集群服务器的负载均衡 紧接着把项目打成war包。然后把项目分别复制到两个tomcat对应的wabapps文件夹（见图4）下面。然后分别在两个tomcat图（4）中的bin文件夹找到startup.bat批处理文件，双击启动服务器。接下来主要工作来了一．Nginx配置负载均衡在图（1）的Nginx的conf文件夹下面找到nginx.conf文件，打开并在该文件的htpp指令模块中添加负载均衡指令（具体添加位置见下图（7）的红色标注区域34行和46行）ont-size:9.0000pt;mso-font-kerning:1.0000pt;” &gt;每个项目的目录内部结构为：图（6）所示：Nginx反向代理实现Tomcat集群服务器的负载均衡 在红色区域添第34行和第46行添加如下命令：第34行红色区添加命令如下：upstream lero{ #其中lero命名可以自定义，但要满足基本的命名规则server 127.0.0.1:8080; #tomcat1服务器的地址server 127.0.0.1:8090; #tomcat2服务器的地址}第46行红色区添加命令如下：proxy_pass http://lero; #配置反向代理指向位置完整的配置见下图（8）Nginx反向代理实现Tomcat集群服务器的负载均衡 一．启动服务器修改配置文件后，需要重新启动nginx服务首先在dos命令窗口定位到nginx服务器安装目录（比如：f:nginx-1.11.13）然后输入重启命令为：nginx -s reload（若这种方法无效，建议强行结束进程）如下图（9）：Nginx反向代理实现Tomcat集群服务器的负载均衡 重启tomcat1，tomcat2服务器（点击shutdown.bat批处理文件后，重新点击startup.bat批处理文件即可实现重启），然后在浏览器地址栏输入127.0.0.1/www.sczhanyi.com/访问第一次效果图（10）：Nginx反向代理实现Tomcat集群服务器的负载均衡 访问第二次效果图（11）Nginx反向代理实现Tomcat集群服务器的负载均衡 访问第三次又会把请求发给tomcat1,访问第四次又会把请求发给tomcat2…到此，已实现了nginx反向代理实现tomcat集群服务器的负载均衡配置。每次访问都会轮换切换服务器,把请求分发给不同的服务器！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux上搭建FTP服务器]]></title>
      <url>%2F2017%2F04%2F17%2FLinux%E4%B8%8A%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[ftp服务基本用法ftp简单来说就是存储静态文件的服务器 12345启动 service vsftpd start重启服务 service vsftpd restart开启 service vsftpd start关闭 service vsftpd stop查看状态 service vsftpd status ftp服务器在Linux上的搭建安装步骤1.通过yum来安装vsftpd 1[root@localhost ~]# yum -y install vsftpd 2.设置为开机启动 1[root@localhost ~]# chkconfig vsftpd on 3.把下面几行注释去掉，让其配置生效： 12345local_enable=YESwrite_enable=YESlocal_umask=022pam_service_name=vsftpduserlist_enable=YES 最新的版本,这些都已经开启 4.配置保存后重启vsftpd服务： 1[root@localhost ~]# service vsftpd restart 添加用户1.环境：ftp为vsftp。被设置用户名为test。被限制路径为/home/test 2.创建建用户：在root用户下： 12useradd -d /home/test test #增加用户test，并制定test用户的主目录为/home/test passwd test #为test用户设置密码 3.更改用户相应的权限设置： 123usermod -s /sbin/nologin test #限定用户test不能telnet，只能ftp usermod -s /bin/bash test #用户test恢复正常 usermod -d /home/test test #更改用户test的主目录为/test 5.如果需要允许用户修改密码，但是又没有telnet登录系统的权限： 1usermod -s /usr/bin/passwd test #用户telnet后将直接进入改密界面 6.如果要删除用户，用下面代码： 1234 在root用户下： userdel -r newuser 在普通用户下： sudo userdel -r newuser 因为需要彻底删除用户，所以加上-r的选项，在删除用户的同时一起把这个用户的宿主目录和邮件目录删除。 配置完成没有意外的话,这个用户已经可以访问了,但是根据环境不同可能出现不同的错误 如果出现权限不对.可根据下面的修改权限 123chmod [who] [+ | - | =] [mode] 文件名chmod 777 -R /home/text]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java常用的jar包]]></title>
      <url>%2F2017%2F04%2F12%2Fjava%E5%B8%B8%E7%94%A8%E7%9A%84jar%E5%8C%85%2F</url>
      <content type="text"><![CDATA[Java开发中主要用到的jar包介绍commons-io.jar：可以看成是java.io的扩展，用来帮助进行IO功能开发．它包含三个主要的领域:Utilityclasses-提供一些静态方法来完成公共任务．Filters-提供文件过滤器的各种实现．Streams-提供实用的Stream，reader与writer实现． commons-beanutils.jar：提供对Java反射和自省API的包装，主要提供了对于 JavaBean进行各种操作。commons-digester.jar:它能方便地将XML文档所定义的元素转化为JAVA对象，其实它的用法有点象栈(当然内在的原理就是那个古老的东西,只是提供了更高一层的封装)。 commons-lang.jar:它扩展了标准 java.langAPI，增加了字符串操作方法、基本数值方法、对象反射、创建和串行化以及System属性。它还包含一个可继承的enum类型、对多种嵌套的Exception类型的支持、对java.util.Date的增强以及用于构建方法的实用程序，例如自动生成 toString()的结果、自动实现hashCode()和equals()方法、数组操作、枚举、日期和时间的处理等等。ArrayUtils–用于对数组的操作，如添加、查找、删除、子数组、倒序、元素类型转换等；BitField–用于操作位元，提供了一些方便而安全的方法；BooleanUtils–用于操作和转换boolean或者Boolean及相应的数组；CharEncoding–包含了Java环境支持的字符编码，提供是否支持某种编码的判断；CharRange–用于设定字符范围并做相应检查；CharSet–用于设定一组字符作为范围并做相应检查；CharSetUtils–用于操作CharSet；CharUtils–用于操作char值和Character对象；ClassUtils–用于对Java类的操作，不使用反射；ObjectUtils–用于操作Java对象，提供null安全的访问和其他一些功能；RandomStringUtils–用于生成随机的字符串；SerializationUtils–用于处理对象序列化，提供比一般Java序列化更高级的处理能力；StringEscapeUtils–用于正确处理转义字符，产生正确的Java、JavaScript、HTML、XML和SQL代码；StringUtils–处理String的核心类，提供了相当多的功能；SystemUtils–在java.lang.System基础上提供更方便的访问，如用户路径、Java版本、时区、操作系统等判断；Validate–提供验证的操作，有点类似assert断言；WordUtils–用于处理单词大小写、换行等。commons-codec.jar：包含一些通用的编码解码算法。包括一些语音编码器，Hex,Base64, 以及URLencoder。 commons-collections.jar：提供一个类包来扩展和增加标准的JavaCollection框架。Bag接口：适用于包含一个对象的多个拷贝的集合Buffer接口：适用于具有顺序的集合类，例如FIFOs(先进先出)BidiMap(双向映射)：可以通过值查找键，也可以通过键查找值Map迭代器：提供了对映射的快速迭代对类型检查进行了封装，确保特定类的实例可以被添加到集合中对转换进行了封装，将集合中的对象转换成被加入时的类型对集合进行组合，使多个集合看起来就像一个集合一样有序映射和set，保持元素添加时的顺序，包括一个基于LRU的map标识映射可以给予对象的==来比较对象，而不是基于equals方法引用映射可以允许键and/or值可以有控制的进行回收很多比较器的实现很多迭代器的实现从数组或者枚举到集合的适配器用来测试或者创建典型set理论的集合属性，例如与、或、闭包 commons-dbutil.jar:对传统操作数据库的类进行二次封装，可以把结果集转化成List(1)org.apache.commons.dbutilsDbUtils : 提供如关闭连接、装载JDBC驱动程序等常规工作的工具类QueryRunner: 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。QueryLoader: 属性文件加载器，主要用于加载属性文件中的SQL到内存中。(2)org.apache.commons.dbutils.handlersArrayHandler：将ResultSet中第一行的数据转化成对象数组ArrayListHandler将ResultSet中所有的数据转化成List，List中存放的是Object[]BeanHandler：将ResultSet中第一行的数据转化成类对象BeanListHandler：将ResultSet中所有的数据转化成List，List中存放的是类对象ColumnListHandler：将ResultSet中某一列的数据存成List，List中存放的是Object对象KeyedHandler：将ResultSet中存成映射，key为某一列对应为Map。Map中存放的是数据MapHandler：将ResultSet中第一行的数据存成Map映射MapListHandler：将ResultSet中所有的数据存成List。List中存放的是MapScalarHandler：将ResultSet中一条记录的其中某一列的数据存成Object java开发中主要用到的jar包总结axis.jar:SOAP引擎包jaxrpc.jar:Axis运行所需要的组件包saaj.jar:创建到端点的点到点连接的方法、创建并处理SOAP消息和附件的方法，以及接收和处理SOAP错误的方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139wsdl4j-1.5.1.jar:Axis运行所需要的组件包activation.jar:JAF框架的jar包annotations-api.jar:使用注解所需jarant.jar:用于自动化调用程序完成项目的编译，打包，测试等aopalliance-1.0.jar:支持spring AOPasm-2.2.3.jar:ASM字节码库asm-commons-2.2.3.jar:ASM字节码库asm-util-2.2.3.jar:Java字节码操纵和分析框架aspectjrt.jar:处理事务和AOP所需的包aspectjweaver.jar:处理事务和AOP所需的包axiom-api-1.2.7.jar:Axis 对象模型axiom-impl-1.2.7.jar:Axis 对象模型bcprov-jdk15-140.jar:基于java1.5 的加密算法实现bfmclientmodel.jar:使用WebSphere所需jar包bpcclientcore.jar:使用WebSphere所需jar包bpe137650.jar:提供远程访问BPE容器的实现。 bsh-2.0b4.jar:解决负载逻辑运算c3p0-0.9.0.jar:开放源代码的JDBC连接池cglib-nodep-2.1_3.jar:Spring中自动代理所需jar包cobertura.jar:测量测试覆盖率commons-beanutils-1.7.0.jar:动态的获取/设值Java Bean的属性commons-chain-1.1.jar:实现责任链设计模式的Java 类库commons-codec-1.3.jar:用来处理常用的编码方法的工具类包，例如DES、SHA1、MD5、Base64等等commons-collections-3.1.jar:对标准java Collection的扩展commons-collections.jar:对标准java Collection的扩展commons-discovery-0.2.jar:用来发现、查找和实现可插入式接口，提供一些一般类实例化、单件的生命周期管理的常用方法.db2jcc.jarjava连接DB2所需jarcommons-digester-1.8.jar:用于处理struts-config.xml配置文件commons-fileupload-1.1.1.jar:struts上传文件commons-httpclient-3.1.jar:用来简化HTTP客户端与服务器端进行各种通信编程实现commons-io-1.1.jar:针对java.io.InputStream和Reader进行了扩展commons-lang-2.4.jar:对java.lang.*的扩展commons-logging-1.1.1.jar:日志包commons-pool-1.3.jar:实现对象池化框架commons-validator-1.3.1.jar:用来把验证规则程序提取出来，以供重复使用db2jcc_license_cu.jar:java:连接DB2所需jardom4j-1.6.1.jar:解析XMLehcache-1.2.4.jar:hibernate的二级缓存如果用ehcache的时候需要此jar包emf.jar:基于Eclipse的模型框架ezmorph-1.0.6.jar:使用JSON所需的jar包FastInfoset-1.2.2.jar:使用WebService所需的jar包freemarker-2.3.8.jar:Strus2支持的一种表现层框架geronimo-activation_1.1_spec-1.0.2.jar:Apache Geronimo所带jar包，geronimo-annotation_1.0_spec-1.1.1.jar:Apache Geronimo所带jar包geronimo-javamail_1.4_spec-1.3.jar:Apache Geronimo所带jar包geronimo-jaxws_2.1_spec-1.0.jar:Apache Geronimo所带jar包geronimo-jms_1.1_spec-1.1.1.jar:Apache Geronimo所带jar包geronimo-servlet_2.5_spec-1.2.jar:Apache Geronimo所带jar包geronimo-stax-api_1.0_spec-1.0.1.jar:Apache Geronimo所带jar包hibernate3.jar:Hibernate3的核心jar包htmclientmodel.jar:使用WebSphere所需jar包jakarta-oro.jar:一套文本处理工具，提供per15.0兼容的表达式，AWK-like表达式，Glob表达式。javassist.jar:Javassist 字节码解释器jaxb-api-2.1.jar:使用WebService所需的jar包jaxb-impl-2.1.7.jar:使用CXF所需jar包jaxb-xjc-2.1.7.jar:使用CXF所需jar包jaxen-1.1.1.jar:解析XMLjcifs-1.2.22.jar:实现单点登陆jdom2-1.0.jar:解析XMLjdom-1.0.jar:解析XMLjettison-1.0.1.jar:使用CXF所需jar包jetty-6.1.9.jar:Jetty Http服务器jarjetty-util-6.1.9.jar:Jetty Http服务器jarjra-1.0-alpha-4.jar:使用CXF所需jar包js-1.6R7.jar:使用CXF所需jar包json-lib-2.2.3-jdk13.jar:使用JSON所需的jar包jsonplugin-0.25.jar:strus2的JSON插件jsr311-api-0.8.jar:使用CXF所需jar包jstl.jar:JSTL标签库jta.jar:标准的 JAVA 事务处理接口junit.jar:用于单元测试jxl.jar:通过java操作excel表格的工具类库ldap.jar:JNDI目录服务和LDAO服务器所需的jarldapbp.jar:JNDI目录服务和LDAO服务器所需的jarlog4j-1.2.15.jar:提供日志功能mail.jar:java发送邮件jar包neethi-2.0.4.jar:使用CXF所需jar包odmg-3.0.jar:ODMG是一个ORM的规范，Hibernate实现了ODMG规范，这是一个核心的库ognl-2.6.11.jar:struts2中OGNL语言ojdbc14.jar:Oracle数据库驱动包opensaml-1.1.jar:使用CXF所需jar包oro-2.0.8.jar:Validator框架所需的jar包oscache-2.1.jar:Java 对象的缓存工具poi-3.1-FINAL-20080629.jar:操作exce所需jar包poi-contrib-3.1-FINAL-20080629.jar:操作exce所需jar包poi-ooxml-3.6-20091214.jar:提供对office的word、excel、visio及ppt的操作poi-ooxml-schemas-3.6-20091214.jar:提供对office的word、excel、visio及ppt的操作poi-scratchpad-3.1-FINAL-20080629.jar:提供对office的word、excel、visio及ppt的操作processCommon.jarIBM WebSphere:运行所需jarProcessCommonLibrary.jarIBM WebSphere:运行所需jarprocessIdentity.jarIBM WebSphere:运行所需jarProcessInformation.jar:进程监视软件包proxool-0.9.1.jar:数据库连接池proxool-cglib.jar:数据库连接池quartz-1.6.0.jar:开源作业调度框架saaj-api-1.3.jar:使用axis所需的jarsaaj-impl-1.3.2.jar:使用axis所需的jarserializer-2.7.1.jar:XML序列化slf4j-jdk14-1.5.6.jar:整合各种日志框架的工具spring208.jar:spring核心框架spring-ldap-1.2-RC1.jar:spring下LDAPspring-mock.jar:spring的测试框架standard.jar:使用JSTL标签库所需的jarstax-api-1.0.1.jar:解析XMLstruts2-core-2.0.14.jar:struts2核心jarstruts2-spring-plugin-2.0.6.jar:struts2整合Spring所需jartaglibs-datetime.jar:Apache开源组织提供标签库，用于格式化日期。taglibs-mailer.jar:用于发送邮件taglibs-string.jar:Apache开源组织提供标签库，用于对String的操作。task137650.jar:Portal技术在SOA系统集成应用中实现所需的jarutility.jar:Apache开源组织提供标签库velocity-1.5.jar:一个免费的开源模板框架wsdl4j-1.6.2.jar:用来解析服务的WSDl文件wss4j-1.5.4.jar:创建CXF所需jarwstx-asl-3.2.6.jar:创建CXF所需jarxbean-spring-2.8.jar:使用xfire所需jarxerces-2.6.2.jar:XML解析器xfire-all-1.2.6.jar:用于实现WebServiceXmlSchema-1.1.jar:使用xfire所需jarxwork-2.0.7.jar:WebWork核心jar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-web基本应用]]></title>
      <url>%2F2017%2F04%2F11%2Fjava-web%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Spring Validation（使用Hibernate Validator）判断表单 数据是否空,大小,email…..1、需要的jar包hibernate-validator.5.1.3.Final.jar validation-api.1.1.0.Final.jar 在spring3之后，任何支持JSR303的validator（如Hibernate Validator）都可以通过简单配置引入，只需要在配置xml中加入，这时validatemessage的属性文件默认为classpath下的ValidationMessages.properties：12&lt;!-- support JSR303 annotation if JSR 303 validation present on classpath --&gt;&lt;mvc:annotation-driven /&gt; 注解123456789101112131415161718192021Bean Validation 中内置的 constraint @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 使用在对象中 12345public class Customer &#123; 7 8 @NotEmpty //make sure name is not empty 9 String name;10 在controller中 12345678910111213public class SignUpController &#123;14 15 @RequestMapping(value = &quot;/signup&quot;, method = RequestMethod.POST)16 public String addCustomer(@Valid Customer customer,(这里使用) BindingResult result) &#123;17 18 if (result.hasErrors()) &#123;19 return &quot;SignUpForm&quot;;20 &#125; else &#123;21 return &quot;Done&quot;;22 &#125;23 24 &#125; 文件上传]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ruby脚本进行提交git或git私有库]]></title>
      <url>%2F2017%2F04%2F10%2FRuby%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E6%8F%90%E4%BA%A4git%2F</url>
      <content type="text"><![CDATA[Ruby脚本进行提交git和git私有库简单的ruby脚本 提交git本地 提交git远程 制作好远程私有库,提交到远程私有库 制作好远程公有库github,提交到github github:https://github.com/winsions/RubyToGit.git 用法把文件夹中的 fastlane文件复制到项目的根目录 提交到git (本地和远程) 复制:提到本地git1文件 或者提到远程git2文件cd到项目执行 下面命令 1fastlane ManagerLib message:本次所修改的描述 提交私有库或者公有库 复制:提交到公有库github3文件 或者提交到私有库4文件cd到项目执行 下面命令 1fastlane ManagerLib tag:0.1.0(标签号) target:项目的名字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[有用的网站都在这里]]></title>
      <url>%2F2017%2F04%2F10%2F%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%2F</url>
      <content type="text"><![CDATA[真的有用各种操作系统 工具什么样的都有http://www.itellyou.cn/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo的简单使用]]></title>
      <url>%2F2017%2F04%2F10%2Fhexo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[hexo的简单使用创建新博客的cd到hexo的根目录文件1hexo new post &quot;hexo的简单使用&quot; (标题) 分布1hexo g 调试模式1hexo s --debug 启动服务1hexo s 上传github1hexo d]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git的简单使用]]></title>
      <url>%2F2017%2F04%2F06%2Fgit%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[git的简单使用查看远程库信息，使用 1git remote -v; 本地新建的分支如果不推送到远程，对其他人就是不可见的; 从本地推送分支，使用 12git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交; 在本地创建和远程分支对应的分支，使用 本地和远程分支的名称最好一致; 1git checkout -b branch-name origin/branch-name， 建立本地分支和远程分支的关联，使用 1git branch --set-upstream branch-name origin/branch-name; 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 1git pull origin master 分支查看当前在哪个分支1git branch 切换分支1git checkout develop 合并分支1git merge --no-ff develop 创建分支 1git checkout -b feature-x(新分支的名字) develop(基础分支) 删除分支1git branch -d feature-x 删除本次所有的修改,回到这一版本最干净的状态12git clean -df (删除变异的临时文件)git reset --hard (删除修改的文件) 如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。12git push origin test:master // 提交本地test分支作为远程的master分支git push origin test:test // 提交本地test分支作为远程的test分支 1git push --set-upstream origin develop 提交本地分支到远程新的分支 如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。 1git push origin :test // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心 Git回滚分支首先备份当前的master分支，防止回滚失败。 从origin master中新建一个分支，名称随便，比如，master_backup。 备份完成后，将master回滚到指定的版本,注意这个地方，是将本地的master分支回滚到指定的版本1git reset --hard commit-id 回滚本地master完成后，将回滚后的代码push到远端master，覆盖远端master分支。方法为：通过git命令，必须通过命令来，sourcetree的方式不可行。 1git push -f origin master。必须有-f，表示强制的意思。 此时，会要求用户输入远端仓库的用户名和密码，用于确认当前用户具有-f的权限。 push成功后，就可以删除备份的master了。sourcetree的方式也是不可以的1git branch -D master_backup tag 加标签添加标签 12git tag 0.1.0;git tag -a v0.1.2 -m “0.1.2版本” 发布标签12git push origin v0.1.2git push --tags 切换1git checkout [tagname] 删除1git tag -d v0.1.2 # 删除标签 删除远程标签1git push origin :refs/tags/标签名 git远程连接git删除远程连接1git remote rm origin 添加远程连接1git remote add origin 远程仓库地址 1git push --set-upstream origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从iOS转战JavaWeb]]></title>
      <url>%2F2017%2F04%2F01%2F%E4%BB%8EiOS%E8%BD%AC%E6%88%98JavaWeb%2F</url>
      <content type="text"><![CDATA[需要持续不段的学习才行hexo的简单命令12345678910111213hexo new&quot;postName&quot; #新建文章hexo new page&quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[出游小记]]></title>
      <url>%2F2017%2F04%2F01%2Fhello-world%2F</url>
      <content type="text"><![CDATA[贸然的一次出行突然间的放松电脑已经成为我的习惯，突然发现自己好像少了某些重要的东西–电脑，原来已经三天没摸电脑了，电脑已成为我生活的一部分了。但是出游让我学到了其他的存在。 生活随心长时间的办公室生活已经让我不知道改怎么释放自己，总是很在乎别人怎么看，好像自己是在为别人而活。看到一对夫妻在公园玩，高高兴兴的啃着北京方便面，然而有些人却扯着嘴角在笑，他们依然在到处游玩，不要为别人的想法而影响自己，在不影响公共秩序的情况下，做我们自己想做的事情，让自己开心的事情，何乐不为呢。看到某一个逗逼，把吃饭盒放在一个大酒缸的前面，旁边人来人往，自己放了5毛钱，让我给他拍照。我当时的第一想法是：丢不丢人啊，这么多人看着，照片我都不想拍，可是别人都不认识我，我怕什么呢。当然这只是一个最简单的解释，我们玩我们自己的，有没有影响到别人，管他怎么看呢，我开心就好，出来玩嘛本身就图个开心。其实我也想玩很多，但就是怕别人看到笑话，而不敢做，这不是违背了我们出来玩的初衷吗？这并不是没心没肺，只是在生活中腰做真实的自己。关心身边的人，这次被一个向导无微不至的照顾，让我无地自容啊，此处省略一万字。。。。。。 沟通这是人与人的社会，沟通无处不在，如果只有你一个人倒也显得无趣。鼓起勇气只要能开个头，就又可能聊下去，可能又多了一个朋友，或者增长一下见闻，毕竟每一个人的经历都是不同的。比如在飞机上，没手机可玩，大家要么睡觉，要么双眼无神的看着远方，其实和身边的人聊一聊，时间过的也挺快呢，还能了解一下别人的人经历，也有可能就多了一个人生中的朋友，说的庸俗一点，也有可能是你下一个发财的机会。 小结没有文彩，就当记一下流水账喽，发现自己的缺点，就要努力去攻克他，早上走向人生巅峰，赢取心爱的她。]]></content>
    </entry>

    
  
  
</search>
