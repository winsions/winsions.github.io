<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS之实际网络状态连接检测]]></title>
      <url>%2F2017%2F05%2F05%2FiOS%E4%B9%8B%E5%AE%9E%E9%99%85%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E8%BF%9E%E6%8E%A5%E6%A3%80%E6%B5%8B%2F</url>
      <content type="text"><![CDATA[iOS之实际网络状态连接检测网络连接状态检测对于我们的iOS app开发来说是一个非常通用的需求但事实上，基于此方案的所有实现，都无法帮助我们检测真正的网络连接状态，它们能检测的只是本地连接状态；如下场景就不能检测到: 1231. 现在很流行的公用wifi，需要网页鉴权，鉴权之前无法上网，但本地连接已经建立；2. 存在了本地网络连接，但信号很差，实际无法连接到服务器；3. iOS连接的路由设备本身没有连接外网。 [Reachability reachabilityWithHostName:]完全没用！ RealReachability简单介绍https://github.com/dustturtle/RealReachability可以办到多方研究后引入了ping能力（此方案流量开销最小，也最简单），实现了简单的实际网络连接监测 集成和使用介绍集成最简便的集成方法当属pod: pod ‘RealReachability’。 手动集成：将RealReachability文件夹加入到工程即可。 使用介绍其接口的设计和调用方法和Reachability非常相似，大家可以无缝上手，非常方便。 开启网络监听： 123 [GLobalRealReachability startNotifier]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkChanged:)name:kRealReachabilityChangedNotificationobject:nil]; 回调代码示例： 123456- (void)networkChanged:(NSNotification *)notification&#123; RealReachability *reachability = (RealReachability *)notification.object; ReachabilityStatus status = [reachability currentReachabilityStatus]; NSLog(@&quot;currentStatus:%@&quot;,@(status));&#125; 触发实时网络状态查询代码示例： 123456789101112131415161718192021222324[GLobalRealReachability reachabilityWithBlock:^(ReachabilityStatus status) &#123; switch (status) &#123; case NotReachable: &#123; // case NotReachable handler break; &#125; case ReachableViaWiFi: &#123; // case ReachableViaWiFi handler break; &#125; case ReachableViaWWAN: &#123; // case ReachableViaWWAN handler break; &#125; default: break; &#125; &#125;]; 查询当前实际网络连接状态： 1ReachabilityStatus status = [reachability currentReachabilityStatus]; realReachability架构概要图RealReachability主要包含3大模块：connection、ping、FSM； 其中Ping模块通过对同样是苹果提供的ping样例代码进行了封装，connection模块实现了基于SCNetworkReachability的本地状态检测，FSM模块是有限状态机。通过FSM的状态管理控制connection模块和Ping模块协同工作，并通过可配置的定时策略等业务逻辑优化，最终得到了我们的实现。 其中connection模块和ping模块也可独立使用，分别提供本地网络检测和ping的能力，感兴趣的读者也可以尝试（调用方式请参考RealReachability开源代码）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之抽屉MMDrawerController]]></title>
      <url>%2F2017%2F05%2F04%2FiOS%E4%B9%8B%E6%8A%BD%E5%B1%89MMDrawerController%2F</url>
      <content type="text"><![CDATA[MMDrawerControllerhttps://github.com/Flyfishering/MMDrawerController这是一个抽屉导航控制器, 越来越多的应用开始使用抽屉效果, 这个库是 轻量级的 抽屉导航控制器 创建 MMDrawerControllerMMDrawerController 是一个容器控制器(和 UINavigationController或者UITabBarController相似)拥有三个自控制器,中部,左边抽屉,右边抽屉,创建 MMDrawerController 前必须先创建上面提到的三个自控制器(左中右),然后调用下面给出的初始化方法 来初始化 1234-(instancetype)initWithCenterViewController:(UIViewController *)centerViewController leftDrawerViewController:(UIViewController *)leftDrawerViewController rightDrawerViewController:(UIViewController *)rightDrawerViewController; UINavigationController 可以作为 中部 的子控制器MMDrawerController 自动支持 UINavigationController 作为 中部 自控制器, 可以正确管理view上的手势(无论是navigation bar view 还是 viewController 的view).这个库 也支持包含 其他控制器容器, 这时 手势开关 不接受定制 从子控制器 获取 MMDrawerController子控制器 可以通过 分类(UIViewController+MMDrawerController) 来 获取关于 容器 MMDrawerController 的信息即使 子控制器 包含在 UINavigationController 中, 在这个库中 自控制器的 容器 默认是 MMDrawerController .更多 关于 这个分类的信息, 去该分类中查看MMDrawerOpenCenterInteractionMode控制了 当抽屉打开时 用户和中部控制器交互的模式. 默认是 MMDrawerOpenCenterInteractionModeNavigationBarOnly 只允许 中部控制器的导航栏可以交互,MMDrawerOpenCenterInteractionModeNone: 禁止用户和中部控制器有任何交互MMDrawerOpenCenterInteractionModeFull: 用户可以和中部控制器任何地方交互注意: 无论设置什么模式, 都不会影响 单击中部控制器 的 手势 去关闭抽屉(MMCloseDrawerGestureMode)540832-54821bf1d9792d17.gif 如上图: ##选择OPEN CENTER INTERACTION MODE None 无法滑动 中间控制器 不能点击导航栏 菜单按钮Full 可滑动 中间控制器 可以点击 导航栏 菜单按钮Nav Bar Only 不能滑动 中间控制器 可以点击 导航栏 菜单按钮打开和关闭 抽屉的手势每个抽屉实例都被添加了 两个手势, 拖动手势 和 单击手势,MMDrawerController 识别这些手势,根据打开和关闭手势的识别 和 抽屉控制器的当前状态, 来决定 这个手势 是否 传递下去启用 重用标志为了 恢复 MMDrawerController ,你必须给 中部控制器,左边抽屉,右边抽屉 和 MMDrawerController 设置重用标志restorationIdentifier, 这样, 你的应用在 进入后台 或者下次启动时 会 存储 抽屉的打开状态.这个库 不支持 下面的操作1.不支持 顶部 或者 底部 抽屉2.不支持 同时 打开 左右 抽屉3.不支持 显示最小抽屉宽度(没看懂)4.不支持 将容器控制器设置为 中部控制器 (UINavigationController 除外)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之动画Lottie]]></title>
      <url>%2F2017%2F05%2F04%2FiOS%E4%B9%8B%E5%8A%A8%E7%94%BBLottie%2F</url>
      <content type="text"><![CDATA[什么是Lottie？首先要说的是：什么是Lottie呢？由Airbnb开发的Lottie是一个将After Effects动画提供给任意一个iOS，macOS，Android还有React Native原生APP的文件库。这些动画通过一个叫Bodymovin的开源After Effects插件，以JSON文件的形式进行输出。Lottie通过JSON格式下载动画数据并实时提供给开发者。 换句话说，你也可以通过设计器直接把JSON文件放入Xcode project，让Lottie帮你下载动画。当然别误会，你还是需要为你的动画写一些代码，但是你会发现Lottie的确将为你的动画编码节省大量的时间。 Lottie现在不仅在GitHub上已经开源，而且还提供一个示例项目和一系列的示例动画，看看下面有没有你能用在iOS Apps当中示例动画吧。 Lottie 动画文件在使用Lottie之前，你需要一个以JSON文件形式输出的动画数据库。如果你已经有了一个After Effects动画，用Bodymovin插件来创建JSON文件。 如果你不会使用After Effects呢？你要如何准备你的动画？你可以雇一位设计师为你设计动画，或者你学会用After Effects。 幸运的是，这里还有一个选项，那就是：Lottie Files(能下载动画的json文件) Lottie Files是一个拥有高质量Lottie文件格式动画的网站。在这个网站，不仅设计师可以在上面陈列他们的动画而且还提供免费下载。像我一样没有After Effects使用经验的人一定会觉得这个动画库非常好用！ 在Xcode中使用Lottie如果你已经有了一个动画文件，剩下的就是准备好Xcode project。和iOS库相似地，最容易的方法就是用CocoaPods将Lottie放入Xcode 项目中。 让我们来做个演示看看Lottie是怎样工作的。 首先，启动Xcode并用Single View Application范本创建一个新项目，把新项目命名为LottieDemo（或任意你喜欢的名字）并保存。 用CocoaPods安装Lottie动画库当你创建完项目，离开Xcode，打开Terminal。我们将为安装Lottie动画库创建一个Podfile。我想你应该已经有一些使用CocoaPods的经验并且已经把它安装在你的电脑中了。 在terminal中运行下列指令来创建一个Podfile。 1234567target &apos;LottieDemo&apos; do # Comment the next line if you&apos;re not using Swift and don&apos;t want to use dynamic frameworks use_frameworks! # Pods for LottieDemo pod &apos;lottie-ios&apos;end 添加Animation JSON Files如果你用自己的动画文件对Lottie进行测试最好，但没有也没关系，从lottiefiles.com下载这个JSON格式的免费文件，我们将用这个文件做个快速的演示。 现在把JSON文件 (servishero_loading.json)拖入Xcode项目的工程管理器，把它放入LottieDemo小组。 创建多动画视图现在来到有趣的部分了，你将用不到10行代码就能执行这个示例动画。 打开ViewController.swift，然后加入一行代码将Lottie 动画库输入进去： 1import Lottie 接下来更新viewDidLoad()如下： 1234567891011121314override func viewDidLoad() &#123; super.viewDidLoad() if let animationView = LOTAnimationView(name: &quot;servishero_loading&quot;) &#123; animationView.frame = CGRect(x: 0, y: 0, width: 400, height: 400) animationView.center = self.view.center animationView.contentMode = .scaleAspectFill view.addSubview(animationView) animationView.play() &#125; &#125; 上面就是你播放动画需要的代码。在Lottie中有个LOTAnimationView分类可以直接从JSON文件下载动画数据。你要先用你已经下载好的JSON文件创建一个LOTAnimationView对象，你才能展示这个动画。 LOTAnimationView是UIView的一个子分类，所以你只要像执行其他视图一样执行LOTAnimationView就可以了。我们先将它的大小重置，放在中心位置，把内容模式设为Aspect Fill；然后我们调用addSubview把动画视图添加到主视图；最后，我们调用play()播放动画。 循环动画默认情况下，动画只播放一次。如果你想循环播放动画，你可以把loopAnimation属性设为true如下： 1animationView.loopAnimation = true LOTAnimationView 分类也为你自定义动画提供了大量属性。如果你想放慢动画播放速度，只要像下面这样改变animationSpeed属性就行了： 1animationView.animationSpeed = 0.5 从远程服务器上载入Animation JSON File你不仅可以把JSON文件保存在本地，而且可以把动画数据保存在远程服务器上。Lottie已经为开发者从远程URL上下载JSON文件准备好了API。用下面的代码替换animationView的初始化界面，看看你会得到什么样的动画。 1let animationView = LOTAnimationView(contentsOf: URL(string: &quot;https://github.com/airbnb/lottie-ios/raw/master/Example/Assets/PinJump.json&quot;)!) 动画视图转换LOTAnimationView和UIView一样都支持不同类型的动画转换。你可以通过合理地设置转换属性对动画进行旋转，大小重置，位置重置。下面是一个把动画顺时针转换45度的转换示例： 12let rotateTransform = CGAffineTransform(rotationAngle: 45.0)animationView.transform = rotateTransform 似的，你可以像其他标准UIView对象一样把UIView动画覆盖在原来的动画上。我们在现有的动画上重建一不同大小的动画。用下面的代码把viewDidLoad()替换掉： 123456789101112131415161718192021222324override func viewDidLoad() &#123; super.viewDidLoad() if let animationView = LOTAnimationView(name: &quot;servishero_loading&quot;) &#123; animationView.frame = CGRect(x: 0, y: 0, width: 400, height: 400) animationView.center = self.view.center animationView.loopAnimation = true animationView.contentMode = .scaleAspectFill animationView.animationSpeed = 0.5 // Applying UIView animation let minimizeTransform = CGAffineTransform(scaleX: 0.1, y: 0.1) animationView.transform = minimizeTransform UIView.animate(withDuration: 3.0, delay: 0.0, options: [.repeat, .autoreverse], animations: &#123; animationView.transform = CGAffineTransform.identity &#125;, completion: nil) view.addSubview(animationView) animationView.play() &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之GCD多线程]]></title>
      <url>%2F2017%2F05%2F04%2FiOS%E4%B9%8BGCD%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[多线程之GCD多线程是在一部处理耗时的任务,在主线程更新UI最简单的GCD的用法,GCD会自动根据任务在多核处理器上分配资源，优化程序。 常用的方法dispatch_async123456dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 耗时的操作 dispatch_async(dispatch_get_main_queue(), ^&#123; // 更新界面 &#125;); &#125;); dispatch_group_async的使用dispatch_group_async可以实现监听一组任务是否完成，完成后得到通知执行其他的操作。这个方法很有用，比如你执行三个下载任务，当三个任务都下载完成后你才通知界面说完成的了。下面是一段例子代码： 123456789101112131415161718dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;group1&quot;); &#125;); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;group2&quot;); &#125;); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:3]; NSLog(@&quot;group3&quot;); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;updateUi&quot;); &#125;); dispatch_release(group); dispatch_group_async是异步的方法，运行后可以看到打印结果： 123456gcdTest[43328:11303] group1gcdTest[43328:12a1b] group2gcdTest[43328:13003] group3gcdTest[43328:f803] updateUi每个一秒打印一个，当第三个任务执行后，upadteUi被打印。 dispatch_barrier_async的使用dispatch_barrier_async是在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行 123456789101112131415161718dispatch_queue_t queue = dispatch_queue_create(&quot;gcdtest.rongfzh.yc&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;dispatch_async1&quot;); &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:4]; NSLog(@&quot;dispatch_async2&quot;); &#125;); dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;dispatch_barrier_async&quot;); [NSThread sleepForTimeInterval:4]; &#125;); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;dispatch_async3&quot;); &#125;); 打印结果： 1234567gcdTest[45547:11203] dispatch_async1gcdTest[45547:11303] dispatch_async2gcdTest[45547:11303] dispatch_barrier_asyncgcdTest[45547:11303] dispatch_async3 dispatch_apply执行某个代码片段N次 1234dispatch_apply(5, globalQ, ^(size_t index) &#123; // 执行5次&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOSUI调试神器Reveal]]></title>
      <url>%2F2017%2F05%2F02%2FiOSUI%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8Reveal%2F</url>
      <content type="text"><![CDATA[CocoaPods集成Revealfile:///Applications/Reveal.app/Contents/SharedSupport/Documentation/Reveal%20Integration%20Guide.html我们保留一个CocoaPods Podspec，将Reveal集成到您的Xcode项目中。 我们的说明假设您已经将您的项目或工作区配置为与CocoaPod一起使用 - 如果没有，请现在就这样做。 警告：切勿运送与Reveal Server框架链接的产品。下面的Podfile示例将仅将Reveal Server框架链接到使用“Debug”配置编译的应用程序的构建。 将以下内容添加到您的Podfile中： 123target &apos;YourMainAppTargetName&apos; do pod &apos;Reveal-SDK&apos;, :configurations =&gt; [&apos;Debug&apos;]end 该:configurations参数确保只有将Reveal链接到您的调试版本中。 运行pod install在您的项目目录中（或者pod update Reveal-SDK如果您以前在项目中使用了CocoaPods）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac设置环境变量]]></title>
      <url>%2F2017%2F05%2F02%2FMac%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
      <content type="text"><![CDATA[环境变量在~/.bash_profile 中的 1234export PATH=$PATH:/usr/local/apache-tomcat-7.0.72/binexport M2_HOME=/usr/local/maven/apache-maven-3.5.0export PATH=$PATH:$M2_HOME/binexport PATH=$PATH:/Users/winsion/Music/MyHexoBlog/folder]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac显示隐藏文件]]></title>
      <url>%2F2017%2F05%2F02%2FMac%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[显示隐藏文件只要打开终端（位于应用程序——实用工具），将以下代码复制进去然后回车 1defaults write com.apple.finder AppleShowAllFiles -bool YES Finder需要重启才能应用修改，在终端中接着输入 1killall Finder 并回车 恢复隐藏不可见，在终端中输入以下代码并回车 1defaults write com.apple.finder AppleShowAllFiles -bool NO 同样Finder需要重启 1killall Finder]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub上Top100的Objective-C项目]]></title>
      <url>%2F2017%2F05%2F02%2FGitHub%E4%B8%8ATop100%E7%9A%84Objective-C%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[iOS开发必读-GitHub 上Top100 的 Objective-C 项目 AFNetworking 作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest GPUImage 一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 SO上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果 SDWebImage 作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单 RestKit 主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上 ReactiveCocoa 由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 “An open source project that exemplifies this brave new era for Objective-C”, 也有人说它是 Cocoa 的未来, 具体可看唐巧写的这篇 文章 three20 由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 PR 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 Nimbus , 算是 three20 的一个替代品 MBProgressHUD 作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师, 此项目是一款提示框第三方库, 帮助开发者快速应用到项目中) MagicalRecord 作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作 FMDB 一个对 SQLite 进行封装的库, 使用起来方便, 简单 Mantle 作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了. FlatUIKit 收集了很多扁平化 UI 的 iOS 组件, 方便使用 ASIHTTPRequest 一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代) FastImageCache Path 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点 Masonry 一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备 Shimmer Facebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单 SVProgressHUD 又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用 Slate 一款窗口管理应用程序, 但在两年前就已经停止更新了 JSONKit 主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了 Nimbus 作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全 CocoaLumberjack 这是 Mac 和 iOS 的一款强大的日志框架, 配置简单, 多线程, 提供更高级的 log 功能, 可用于代替默认的 NSLog 语句 Facebook SDK for iOS Facebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面 AsyncDisplayKit Facebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎 Alcatraz Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传 ViewDeck 一款开源的 iOS 活动面板组件, 还原 Path 2.0 的侧滑效果, 作者因为时间关系在两年前停止对其更新 JSQMessagesViewController 优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高 FLEX 这是 Flipboard 官方发布的一组专门用于 iOS 开发的应用内调试工具, 开发者无需将其连接到 LLDB/Xcode 或其他远程调试服务器,支持直接在 App 中运行 Xctool 是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, Travis CI , OCLint 等测试工具 OpenEmu 超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错 iCarousel 作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果 RESideMenu 作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8 321 PNChart 作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱 31.2 PonyDebugger 由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试 JVFloatLabeledTextField 作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本 SWTableViewCell UITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮 AwesomeMenu 作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果 Reachability Reachablity 是用于检测 iOS 设备网络环境的库 VVDocumenter-Xcode 作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞 The Physical Web 由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段 NewsBlur 作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码 Cocos2D-SpriteBuilder 一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift, 目前该项目在 GitHub 上更新较为频繁 TTTAttributedLabel UILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能 CocoaAsyncSocket 一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师 TapkuLibrary 作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中 Canvas 无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手 SocketRocket Square 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱 ECSlidingViewController 一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工 Json Framework 用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了 Tweaks Facebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了 realm-cocoa Realm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库 BlocksKit 一个开源的与 Cocoa 紧密集合的基础性框架 Appirater 一款用于提醒用户给你的 App 打分的工具 KIF Square 出品的一个开源的用户界面测试框架, 极大的简化了 iOS 开发者的 UI 测试流程 SlackTextViewController Slack 推出的一款具有文字输入框高度自适应, 自动输入, 复制单元格内容等功能的解决方案 JazzHands IFTTT 开源的一个简单易用的关键帧基础动画框架, 可通过手势、scroll views, KVO, ReactiveCocoa 等方式来控制动画 Bolts-iOS Bolts 是一个 Parse 和 Facebook 在内部使用的底层库, 方便移动开发 Spectacle 一款易用的 OS X 窗口分屏操作快捷键工具, 这是其源代码 nui 方便样式化 iOS 应用中的 UI 元素, 可在短时间内样式化整个应用, 类 CSS 原理 Induction Induction 是一款用于理解数据关系的管理工具, 这是其程序代码 JSONModel 一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换 DTCoreText 一个开源的 iOS 富文本组件, 它可以解析 HTML 与 CSS 并最终用 CoreText 绘制出来, 通常用于在一些需要显示富文本的场景下代替低性能的 UIWebView Popping 基于 Facebook Pop 引擎的 iOS 动画库, 集合了很多动画效果 TSMessages 一个用来弹出显示警告和通知的轻量级库, 样式丰富, 简单易用 KVOController 一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一 MWPhotoBrowser 一款简单的 iOS 照片浏览控件 MMDrawerController 一个轻量级, 易于使用的侧边抽屉导航 iOS 控件 QuickDialog 用于快速创建复杂的 iOS 表单, 自定义了 UITableViewCell, TableView 的样式 SVPullToRefresh 一款只需一行代码便可集成上拉刷新和下拉加载的组件 cheddar-ios Cheddar 是一款简单易用的日程管理软件, 这是其早期版本的开源代码, 该项目已停止维护 XVim 一款在 Xcode 上实现了 Vim 功能的插件 EGOTableViewPullRefresh 一款提供下拉刷新的控件, 最后更新时间是一年前 iOS-boilerplate iOS 应用程序的基础模板, 使用该模板可以省掉许多项目初始编码的工作, 内置非常多丰富的功能, 现已经停止维护 JASidePanels 一个 UIViewController 容器, 灵感来自 Facebook 和 Path 2.0 应用的菜单, 实现了左右侧滑的操作 FormatterKit 收集了很多构思优秀的 NSFormatter 子类 MSDynamicsDrawerViewController 实现了具有动态弹性效果的抽屉式侧边导航栏, 效果丰富, 可定制性强 idev-recipes iDevRecipes 博客的代码, 演示如何实现一些有趣的控件, 该项目在两年前(2013)停止了更新 XMPPFramework 一个基于 RFC-3920 实现, 支持多线程和线程保护, 同时通用于所有的 iOS 和 Mac OS 开发设备的通信框架. MacGap1 一款可以将 HTML/CSS/JS 网络应用打包成原生 Mac App 的工具 FXBlurView iOS 模糊背景类库, 可以方便的根据底层显示的状态生成模糊效果 iOS7-Sampler 整合演示了多个具有 iOS7 新特性的的项目, 提供了非常多的例子参考 PromiseKit 提供强大的 iOS 开发异步功能, 是 Promises 的实现, 受到广大开发者的追捧 Origami 此为 Facebook 推出的 Quartz Composer 的一个开源插件, 由其设计团队花费了 9 个月打造而成, 目的是为方便设计师快速构建原型, 以零代码完成复杂动画的合成和测试, 堪称神器 NSLogger 一款强大的日志分析工具, 具有大窗口查看 Log, 自定义日志等级等功能 KSImageNamed-Xcode 一款对 UIImage 的 imageNamed 提供自动补全功能的插件, 非常方便 PureLayout 一个简单却强大的 AutoLayout API 库, 兼容了 Objective-C 和 Swift, 扩展了 UIView/NSView, NSArray, 和 NSLayoutConstraint AppleDoc 一款 Objective-C 文档生成工具, 生成的文档风格保持与 Apple 官方的一致, 极大的方便了 Xcode 识别自己写的 API 文档, 安装也是十分的简单 iTerm2 iTerm2 被不少程序员称赞为 Mac 下最好用的终端, 这是其源代码, 配合 oh-my-zsh 使用效果更佳 Kiwi 一个行为驱动开发测试框架, 适用于 iOS 平台, 旨在为开发者提供一个简单配置便可使用的 BDD 库 terminal-notifier 一款命令行工具, 用来给 Mac OS X 用户发送通知 MacDown Mac OS X 下的一款开源的 Markdown 编辑器, 创意来自与 Mou, 使用 brew cask 即可完成安装 TwUI Twitter 开源的一个支持硬件加速的 Mac 的 UI 框架, 最后一次的更新时间是在 3 年前(2012) PaperFold for iOS 实现了类似折纸效果的视图切换, 可从不同方向进行切换, 该项目已经许久未更新 Reader 一款开源的 iOS PDF 阅读器, 附带书签, 列纲要等功能 WebViewJavascriptBridge 一个方便使用 Objective-C 与 JavaScript 进行通信的第三方库, 支持消息发送, 接收, 消息处理器的注册与调用以及设置消息处理的回调 iOS8-Sampler iOSX-Sampler 系列之一, 整合演示了多个具有 iOS8 新特性的的项目, 提供了非常多的例子参考 CocoaHTTPServer 一个用于 Mac OS X 或 iOS 应用的轻量级、可嵌入的HTTP 服务器框架, 方便开发者在应用中嵌入一个 HTTP 服务器 Kod Mac OS X 上一款专为程序员打造的编辑器, 这是其开源代码, 可惜的是作者在 2011 年停止了维护 TPKeyboardAvoiding 下拉键盘在 iOS 移动文本字段的通用解决方案, 能够自动处理键盘弹出后出现遮挡到文本输入框的问题 MKNetworkKit 一个轻量级网络请求框架, 完全基于 ARC, 仅有两个类, 具有自主操作多个网络请求, 更加准确的显示网络活动指标等优点 PKRevealController 一个 iOS 平台上的视图控制器集合, 通过展现多个视图控制器来进行控制器之间的切换. 设置简单, 高度灵活 AQGridView 一个命令行工具, 通过项目里的.xcdatamodel文件, 可以为每个 entity 生成两个类, 方便 CoreData 的使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cocoapods私有库]]></title>
      <url>%2F2017%2F05%2F02%2FCocoapods%E7%A7%81%E6%9C%89%E5%BA%93%2F</url>
      <content type="text"><![CDATA[CocoaPods的使用方法简单使用pod init//编辑podFile文件内容,添加框架名称pod ‘BaiduMapKit’//执行安装命令pod install –no-repo-update 导入百度地图导航pod ‘BaiduNaviSDK-iOS’, ‘~&gt; 3.1.1’ ReactiveCocoa发布了重大的更新，所以如果想使用最新版本的框架，我们需要注意一下问题。 高级使用 如果你只是纯 swift 项目，你继续使用 ReactiveCocoa 。但是 RAC 依赖于 ReactiveSwift ，等于你引入了两个库。这种情况下的podfile的文件如下: 1234use_frameworks! target &apos;Target名称&apos; do pod &apos;ReactiveCocoa&apos;, &apos;5.0.0-alpha.3&apos;end 如果你的项目是纯 OC 项目，你需要使用的是 ReactiveObjC 。这个库里面包含原来 RAC 2 的全部代码。这种情况下的podfile的文件如下: 1234use_frameworks! target &apos;Target名称&apos; do pod &apos;ReactiveObjC&apos;, &apos;~&gt; 2.1.0&apos;end 如果你的项目是 Swift 和 OC 混编，你需要同时引用ReactiveCocoa 和 ReactiveObjCBridge 。但是 ReactiveObjCBridge 依赖于 ReactiveObjC ，所以你就等于引入了 4 个库。其中，ReactiveObjCBridge暂不支持cocoapods导入，需要手动导入！！这种情况下的podfile的文件如下（注意，ReactiveObjCBridge手动导入就好啦）: 12345use_frameworks! target &apos;Target名称&apos; do pod &apos;ReactiveObjC&apos;, &apos;~&gt; 2.1.0&apos; pod &apos;ReactiveCocoa&apos;, &apos;5.0.0-alpha.3&apos;end 创建描述文件创建一个文件 podspec创建一个 podspec 索引库信息pod repo 查看本地索引创建本地索引库 1pod repo add WZCPrivate https://git.codingnet.WZCPrivate.git pod repo push 库的名字 库名.podspecpush 到私有索引库 创建仓库工程模板 pod lib create XXXLib 添加需要的库文件到相应文件夹 关联远程库 git remote add origin 远程仓库地址 打标签, 并提交到远程仓库 1$ git tag -m &quot;初始版本&quot; &quot;0.1.0&quot; 1$ git push --tags #推送tag到远程仓库 验证podspec文件1pod lib lint 向私有的Spec Repo中提交podspec1pod repo push SpecName XXX.podspec 使用pod库12source &apos;git@git.coding.net:wangshunzi/XMGFMSpecs.git&apos;source &apos;https://github.com/CocoaPods/Specs.git&apos; #官方仓库的地址 1pod &apos;XXXLib/XXXSub&apos; 远程私有库依赖问题 在 项目名.podspec 中添加组件依赖 1network.dependency &apos;AFNetworking&apos; 优化创建子库 需要啥用啥]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux的终端操作]]></title>
      <url>%2F2017%2F05%2F02%2FLinux%E7%9A%84%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[终端的基本操作 通过远程工具登陆到linux后，所在的位置是当前登录用户的家目录(home directory)。 家目录的符号用~表示。 linux的文件系统是一个树结构。linux文件系统的树根成为根目录，使用符号”/“表示。linux文件系统中使用符号”..”表示上级目录。linux文件系统中使用符号”.”表示当前目录。linux文件系统中，如果文件使用“.”开头，就表示隐藏文件linux的路径表示方式有两种，一种是绝对路径(以”/“开头的路径)，一种是相对路径 命令cd(change directory)：跳转到其他目录 命令ls：查看目录下包含什么东西 ls -l：显示详细信息 ls -a：显示隐藏文件 命令pwd：显示当前所处位置的 命令clear：清屏//权限 命令mkdir：创建文件夹 mkdir -p ：递归创建上级文件夹 命令touch：创建空白文件 命令more：查看 内容 命令rm：删除文件命令rmdir：删除文件夹命令rm -rf:删除文件(夹)，不论层级多深，一概删除，并且不给出提示 命令cp(copy)：复制文件，还有一个功能是创建新文件 命令mv(move): 移动文件，还有个功能是重命名 VI操作： 当使用命令vi f1回车时，进入了vi编辑器内，处于只读状态(只能看不能写)； 按字母”i“(insert)或者”a“(append)就可以进入编辑状态； 按键盘上的”Esc“键，再按Shift+:，进入命令状态 如果输入命令wq，意味着保存退出； 如果输入命令q！，意味着不保存退出； linux的权限使用9位字符表示，rwx rwx rwx这里面r表示读权限，w表示写权限，x表示执行权限，-表示没有权限 这9位字符，每3位一组，分为3组。第一组表示创建者的权限；第二组表示创建者所在组的权限；第三组表示其他人的权限； 权限还可以使用数字表示。rwx用数字表示为4+2+1=7。新创建文件的默认权限是644；新创建文件夹的默认权限是755. 命令chmod：修改权限，三个组分别使用u、g、o表示，赋权限使用“+”，去掉权限使用“-”。 chmod u+x f1 //表示文件f1的创建者增加执行权限 chmod o-r f1 //表示文件f1的其他人去掉读权限]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[B客户orC用户]]></title>
      <url>%2F2017%2F05%2F02%2FB%E5%AE%A2%E6%88%B7orC%E7%94%A8%E6%88%B7%2F</url>
      <content type="text"><![CDATA[to B or to Cwhat12C:普通对象（customer）B:商业模式（business） 区别客户与用户 1客户是理性的，用户则偏感性 工具与玩具 1客户关心的是ROI（投入产出比），用户要的就是玩的爽（满足了人性的某个弱点） 卖艺与卖身 1客户有大小之分，用户则基本一样]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java注意事项]]></title>
      <url>%2F2017%2F05%2F02%2Fjava%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[二进制计算处理误差问题java中提供了BigDecimal这个超大的类，用来存储浮点型，使用它可以处理二进制误差问题bigdecimal 1234public void Demo1()&#123; BigDecimal b1=new BigDecimal(2.0+&quot;&quot;);//注意：只能使用String类型的构造 System.out.println(b1.subtract(new BigDecimal(1.1+&quot;&quot;)));//0.9 &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql最常用的语法]]></title>
      <url>%2F2017%2F05%2F02%2FMysql%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[MySQL的基本语法left JOIN 左表匹配右表 有没有内容全部匹配 12345SELECT Persons.LastName, Orders.OrderNoFROM PersonsINNER JOIN OrdersON Persons.Id_P=Orders.Id_PORDER BY Persons.LastName 只输出右边的表有内容的 12345SELECT Persons.LastName, Persons.FirstName, Orders.OrderNoFROM PersonsINNER JOIN OrdersON Persons.Id_P=Orders.Id_PORDER BY Persons.LastName RIGHT JOIN 关键字会右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1) 中没有匹配的行。1234SELECT column_name(s)FROM table_name1RIGHT JOIN table_name2 ON table_name1.column_name=table_name2.column_name SQL FULL JOIN 关键字只要其中某个表存在匹配，FULL JOIN 关键字就会返回行。1234SELECT column_name(s)FROM table_name1FULL JOIN table_name2 ON table_name1.column_name=table_name2.column_name UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 123SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2 删除表1drop table `MYFirstTable` 删除数据库1drop database MY_db 复制表1creat table `NewMYFirstTable` select *from `OldMYFirstTable` 修改数据库的编码规则1alter database mydb character set utf8; 创建数据库的时候设置编码规则1CREATE DATABASE db_name DEFAULT CHARACTER SET utf8 创建表&lt;加约束)1234567891011CREATE TABLE Persons(Id_P int NOT NULL,(不接受空值)LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)UNIQUE (Id_P) **约束**PRIMARY KEY (Id_P) **设置主键**) 123SQL UNIQUE 约束UNIQUE 约束唯一标识数据库表中的每条记录。UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。 PRIMARY KEY 约束唯一标识数据库表中的每条记录。主键必须包含唯一的值。主键列不能包含 NULL 值。每个表都应该有一个主键，并且每个表只能有一个主键。 如果表已经存在,择设置主键 12ALTER TABLE PersonsADD PRIMARY KEY (Id_P) 撤销主键约束 12ALTER TABLE PersonsDROP PRIMARY KEY CHECK 约束规定 “Id_P” 列必须只包含大于 0 的整数 1CHECK (Id_P&gt;0) 更新一个数值 1update setUpdefault set neme = &apos;hahhahfrewgerwg&apos; WHERE neme = &apos;hahhah&apos; 创建索引 CREATE INDEX 语句用于在表中创建索引。在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。 注释：更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。 12CREATE INDEX index_nameON table_name (column_name) 删除索引 1DROP INDEX index_name ON table_name 删除表的数据12345TRUNCATE TABLE 表名称delete from tableName//删除部分数据DELETE FROM table1 WHERE ...; 添加列,删除列,改变列的数据类型123456789101112如需在表中添加列，请使用下列语法:ALTER TABLE table_nameADD column_name datatype要删除表中的列，请使用下列语法：ALTER TABLE table_name DROP COLUMN column_name要改变表中列的数据类型，请使用下列语法：ALTER TABLE table_nameALTER COLUMN column_name datatype //设置让主键自增我们通常希望在每次插入新记录时，自动地创建主键字段的值。我们可以在表中创建一个 auto-increment 字段。下列 SQL 语句把 “Persons” 表中的 “P_Id” 列定义为 auto-increment 主键： 1alter table S_Province modify `ProvinceID` integer auto_increment 添加视图123456CREATE VIEW [Current Product List] ASSELECT ProductID,ProductNameFROM ProductsWHERE Discontinued=No我们可以查询上面这个视图：SELECT * FROM [Current Product List] 12 时间的格式12345MySQL 使用下列数据类型在数据库中存储日期或日期/时间值：DATE - 格式 YYYY-MM-DDDATETIME - 格式: YYYY-MM-DD HH:MM:SSTIMESTAMP - 格式: YYYY-MM-DD HH:MM:SSYEAR - 格式 YYYY 或 YY 1SELECT * FROM Orders WHERE OrderDate=&apos;2008-12-26&apos; NULL值我们如何仅仅选取在 “Address” 列中带有 NULL 值的记录呢？我们必须使用 IS NULL 操作符： 12SELECT LastName,FirstName,Address FROM PersonsWHERE Address IS NULL 数据类型 从第几行哦第几行limit 2， 4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[程序员最正确的定义]]></title>
      <url>%2F2017%2F04%2F28%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%80%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
      <content type="text"><![CDATA[程序员最正确的定义##对这个世界抱有永不穷尽的好奇心，持续学习的人才是程序员; ##自己组装电脑，选硬件，帮妹纸装系统，杀毒，修电灯泡，工作上用脚本提升效率，做UI，写业务，造轮子，搭架构等等，这些都是程序员的领地; ##对编程持有源源不绝的动力和激情，在新事物的接纳和学习上敢为人先者，这才是程序员。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之YYkit框架学习]]></title>
      <url>%2F2017%2F04%2F27%2FiOS%E4%B9%8BYYkit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[iOS之YYkit框架学习YYKit 是一组庞大、功能丰富的 iOS 组件。为了尽量复用代码，这个项目中的某些组件之间有比较强的依赖关系。为了方便其他开发者使用，我从中拆分出以下独立组件： YYModel — 高性能的 iOS JSON 模型框架 YYCache — 高性能的 iOS 缓存框架。YYImage— 功能强大的 iOS 图像框架。YYWebImage — 高性能的 iOS 异步图像加载框架。YYText — 功能强大的 iOS 富文本框架。YYKeyboardManager — iOS 键盘监听管理工具。YYDispatchQueuePool — iOS 全局并发队列管理工具。YYAsyncLayer — iOS 异步绘制与显示的工具。YYCategories — 功能丰富的 Category 类型工具库。 YYModel的学习 高性能: 模型转换性能接近手写解析代码。自动类型转换: 对象类型可以自动转换，详情见下方表格。类型安全: 转换过程中，所有的数据类型都会被检测一遍，以保证类型安全，避免崩溃问题。无侵入性: 模型无需继承自其他基类。轻量: 该框架只有 5 个文件 (包括.h文件)。文档和单元测试: 文档覆盖率100%, 代码覆盖率99.6%。 常用的方法: 123456789101112131415161718# json转模型+ (instancetype)yy_modelWithJSON:(id)json;# 模型转字符串- (NSString *)yy_modelToJSONString # 字典转模型+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary ;# 声明数组、字典或者集合里的元素类型时要重写+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelContainerPropertyGenericClass；# 字典里的key值与模型的属性值不一致要重复+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelCustomPropertyMapper;# 下面两者是属性值在两个dic与模型之间的转化方法（自己看代码吧~😂）- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic ；- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic； YYCache的学习 基本介绍 YYCache由YYCache，YYDiskCache，YYMemoryCache和YYKVStorage组成，其中YYKVStorage可直接对sqlite和文件系统进行读写（YYDiskCache的底层实现）; YYCache 如果不指定存储方式，默认存入内存的时候同时写入磁盘从内存中读，有就直接拿来用; 2.没有再从磁盘读，有就拿来用，并写入内存中; 3.仍然没有就返空和指定存储方式一样 YYMemoryCache 将对象存储在内存中存取速度较快短（下次重新启动运用的时候缓存会被清空） YYDiskCache 将对象存储在磁盘中[1]存取速度较慢长（下次重新启动运用的时候缓存仍然存在） 主要api的使用: 12345678910111213141516# 创建YYCache对象(如果有很多对象都对应同一个文件夹，会导致缓存不稳定) @param name 缓存文件夹的名称，一旦被创建我们就不应该对这个文件夹进行读写了(也就是我们应该 用YYCache操作这个文件夹)+ (nullable instancetype)cacheWithName:(NSString *)name;# 判断是否缓存中`key`是否存在- (BOOL)containsObjectForKey:(NSString *)key;# 返回`key`对应的对象- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;# 设置`key`对应的对象- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;# 移除`key`对应的对象- (void)removeObjectForKey:(NSString *)key; 3.封装了一个网络请求累具体思想是: 1234* 1.先加载缓存* 2.判断有没有网络* 3.如果没有网络则return* 4.有网，则继续请求，然后刷新内容，刷新缓存 具体实现:见我的github,欢迎starhttps://github.com/321zhangyang/SPHttpWithYYCache 1234567891011添加 WZCHttp文件到你的工程;需要添加 pod &apos;AFNetworking&apos; pod &apos;YYCache&apos; 两个框架网络请求就比较简单了类方法:[WZCHttp postRequestUrl....][WZCHttp getRequestUrl....]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS之谓词NSPredicate的应用]]></title>
      <url>%2F2017%2F04%2F25%2FiOS%E4%B9%8B%E8%B0%93%E8%AF%8DNSPredicate%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[iOS之谓词NSPredicate的应用说到谓词，我们先来看一下谓词的语法。 比较运算符 &gt;:大于 &lt;:小于 &gt;=:大于等于 &lt;=:小于等于 =,==:等于 !=,&lt;&gt;:不等于 逻辑运算符 and /&amp;&amp;和 or/||或 not/!非 关系运算符 ANY任意，SOME 一些 ALL所有元素 NONE没有元素 等同于not any in包含 范围运算符 between 如，1 BETWEEN { 0 , 33 }，或者$INPUT BETWEEN { $LOWER, $UPPER }。 in包含 字符串本身 SELF 如：@“self＝＝‘APPLEIOS’” 字符串相关 contain between endswith like通配符 like 如:@”name like[cd] ‘ios‘“ @&quot;name&quot; like[cd] &apos;ios*&apos;&quot; 正则表达式matches 如：NSString *regex = @”^A.+e$”; //以A开头，e结尾 @”name MATCHES %@”,regex 数组操作 array[index]：指定数组中特定索引处的元素。 array[first]:制定第一个元素 array[last]:制定最后一个元素 array[size]:制定数组大小 下面我们再来看一下具体的事例： 新建一个项目，然后添加类products 1.Products.h 123456789#import &lt;Foundation/Foundation.h&gt;@interface Products : NSObject@property NSString *productName;@property NSInteger productCount;@property NSString *productImageUrl;+(id)initProductWithName:(NSString *) name withCount:(NSInteger) count withImage:(NSString *) imageurl;@end 2.Products.m 1234567891011121314151617#import &quot;Products.h&quot;@implementation Products+(id)initProductWithName:(NSString *)name withCount:(NSInteger)count withImage:(NSString *)imageurl&#123; Products *sprducts=[[Products alloc] init]; sprducts.productName=name; sprducts.productCount=count; sprducts.productImageUrl=imageurl; return sprducts;&#125;-(NSString *)description&#123; NSString *str=[NSString stringWithFormat:@&quot;产品名称：%@，数量：%ld，图片：%@&quot;,_productName,_productCount,_productImageUrl]; return str;&#125;@end 3.测试方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#import &quot;ViewController.h&quot;#import &quot;Products.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self mainTest];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning];&#125;-(void) mainTest&#123; Products *p1=[Products initProductWithName:@&quot;A苹果sdasf&quot; withCount:2 withImage:@&quot;464.jpg&quot;]; Products *p2=[Products initProductWithName:@&quot;fsdf橘子gag&quot; withCount:53 withImage:@&quot;fsdfas.jpg&quot;]; Products *p3=[Products initProductWithName:@&quot;dfgdf香蕉&quot; withCount:5 withImage:@&quot;sfas.jpg&quot;]; Products *p4=[Products initProductWithName:@&quot;三星&quot; withCount:76 withImage:@&quot;ggas.jpg&quot;]; Products *p5=[Products initProductWithName:@&quot;华为dfsd&quot; withCount:9 withImage:@&quot;gasa.jpg&quot;]; Products *p6=[Products initProductWithName:@&quot;微软dhnnne&quot; withCount:6 withImage:@&quot;hshhh.jpg&quot;]; Products *p7=[Products initProductWithName:@&quot;三星&quot; withCount:6 withImage:@&quot;hshhh.jpg&quot;]; Products *p8=[Products initProductWithName:@&quot;15300250500&quot; withCount:6 withImage:@&quot;hshhh.jpg&quot;]; NSArray *sproducts=[NSArray arrayWithObjects:p1,p2,p3,p4,p5,p6,p7,nil]; //数量小于9 定义谓词 包含过滤条件 NSPredicate *prdicate=[NSPredicate predicateWithFormat:@&quot;productCount&lt;%d&quot;,9]; //过滤结果返回新的数组 NSArray *newArray=[sproducts filteredArrayUsingPredicate:prdicate]; for (Products *item in newArray) &#123; NSLog(@&quot;newArray=%@&quot;,item.productName); &#125; //数量大于9 并且productname等于“三星jfggg” 定义谓词 包含过滤条件 prdicate=[NSPredicate predicateWithFormat:@&quot;productName=&apos;三星&apos; &amp;&amp; productCount&gt;9&quot;]; //过滤结果返回新的数组 newArray=[sproducts filteredArrayUsingPredicate:prdicate]; for (Products *item in newArray) &#123; NSLog(@&quot;newArray=%@&quot;,item.productName); &#125; //in(包含) *注意 包含是全字匹配 prdicate = [NSPredicate predicateWithFormat:@&quot;productName IN &#123;&apos;g&apos;,&apos;华为&apos;,&apos;三星&apos;&#125;||productCount IN &#123;2,5&#125;&quot;]; //过滤结果返回新的数组 newArray=[sproducts filteredArrayUsingPredicate:prdicate]; for (Products *item in newArray) &#123; NSLog(@&quot;newArray=%@&quot;,item.productName); &#125; //productName以a开头的 prdicate = [NSPredicate predicateWithFormat:@&quot;productName BEGINSWITH &apos;A&apos;&quot;]; //productName以ba结尾的 prdicate = [NSPredicate predicateWithFormat:@&quot;productName ENDSWITH &apos;g&apos;&quot;]; //name中包含字符a的 prdicate = [NSPredicate predicateWithFormat:@&quot;productName CONTAINS &apos;a&apos;&quot;]; //like 匹配任意多个字符 //productName中只要有s字符就满足条件 prdicate = [NSPredicate predicateWithFormat:@&quot;productName like &apos;*s*&apos;&quot;]; //?代表一个字符，下面的查询条件是：name中第二个字符是s的 prdicate = [NSPredicate predicateWithFormat:@&quot;productName like &apos;?s*&apos;&quot;]; newArray=[sproducts filteredArrayUsingPredicate:prdicate]; for (Products *item in newArray) &#123; NSLog(@&quot;newArray=%@&quot;,item.productName); &#125; //正则表达式 验证是否是手机号 BOOL isMobileNum=[self isMobileNumber:p8.productName]; if(isMobileNum) NSLog(@&quot;是真确的手机号：%@&quot;,p8.productName); &#125;- (BOOL)isMobileNumber:(NSString *)mobileNum&#123; /** * 手机号码 * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188 * 联通：130,131,132,152,155,156,185,186 * 电信：133,1349,153,180,189 */ NSString * MOBILE = @&quot;^1(3[0-9]|5[0-35-9]|8[025-9])\\d&#123;8&#125;$&quot;; /** * 中国移动：China Mobile * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188 */ NSString * CM = @&quot;^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\\d)\\d&#123;7&#125;$&quot;; /** * 中国联通：China Unicom * 130,131,132,152,155,156,185,186 */ NSString * CU = @&quot;^1(3[0-2]|5[256]|8[56])\\d&#123;8&#125;$&quot;; /** * 中国电信：China Telecom * 133,1349,153,180,189 */ NSString * CT = @&quot;^1((33|53|8[09])[0-9]|349)\\d&#123;7&#125;$&quot;; /** * 大陆地区固话及小灵通 * 区号：010,020,021,022,023,024,025,027,028,029 * 号码：七位或八位 */ // NSString * PHS = @&quot;^0(10|2[0-5789]|\\d&#123;3&#125;)\\d&#123;7,8&#125;$&quot;; NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, MOBILE]; NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CM]; NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CU]; NSPredicate *regextestct = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CT]; if (([regextestmobile evaluateWithObject:mobileNum] == YES) || ([regextestcm evaluateWithObject:mobileNum] == YES) || ([regextestct evaluateWithObject:mobileNum] == YES) || ([regextestcu evaluateWithObject:mobileNum] == YES)) &#123; if([regextestcm evaluateWithObject:mobileNum] == YES) &#123; NSLog(@&quot;中国移动&quot;); &#125; else if([regextestct evaluateWithObject:mobileNum] == YES) &#123; NSLog(@&quot;联通&quot;); &#125; else if ([regextestcu evaluateWithObject:mobileNum] == YES) &#123; NSLog(@&quot;电信&quot;); &#125; else &#123; NSLog(@&quot;Unknow&quot;); &#125; return YES; &#125; else &#123; return NO; &#125;&#125;@end 4.正则表达式，例子是验证是否是手机号 //正则表达式串 NSString MOBILE = @”^1(3[0-9]|5[0-35-9]|8[025-9])\d{8}$”;//创建含有正则表达式的帅选器 NSPredicate regextestmobile = [NSPredicate predicateWithFormat:@”SELF MATCHES %@”, MOBILE];//筛选器的evaluateWithObject方法反向验证是否手机号，返回bool值BOOL isPhoneNum=[regextestmobile evaluateWithObject:@”15300250500”] ;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybaties的基础用法]]></title>
      <url>%2F2017%2F04%2F24%2FMybaties%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Mybaties的基础用法基础用法1.通过条件查询先创建example,添加条件 1234567TbItemExample tbItemExample = new TbItemExample(); TbItemExample.Criteria criteria = tbItemExample.createCriteria(); criteria.andIdEqualTo(id); List&lt;TbItem&gt; tbItems = tbItemMapper.selectByExample(tbItemExample); item = tbItems.get(0); 2.分页插件的基本使用 在调价查询前,加上 1PageHelper.startPage(page, rows); page是页数,rows是每页显示的条数 总页数,查询之后 12PageInfo&lt;TbItem&gt; pageInfo = new PageInfo&lt;TbItem&gt;(tbItems); **总页数** pageInfo.getTotal(); 3.基本的查询 insert delete update select 高级用法1.复杂的表结构,多表关联 在map.java中添加新的方法 在对应的XML文件中实现这个方法 1234567891011121314 1.添加对结果的映射 &lt;resultMap id=&quot;ResultMapAndItemName&quot; type=&quot;com.taotao.pojo.TbItemParam&quot; extends=&quot;BaseResultMap&quot;&gt; &lt;result column=&quot;param_data&quot; property=&quot;paramData&quot; jdbcType=&quot;LONGVARCHAR&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;itemCatName&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/resultMap&gt; **column是数据库中字段的名字,property是表中的属性的名字.type是返回结果对一个的ben** 2.实现map中的方法 &lt;select id=&quot;selectItemParamAndItemCat&quot; resultMap=&quot;ResultMapAndItemName&quot; parameterType=&quot;com.taotao.pojo.TbItemParam&quot;&gt;SELECT tb_item_param.id,item_cat_id,param_data,tb_item_param.created,tb_item_param.updated,name from tb_item_paramLEFT join tb_item_cat on tb_item_param.item_cat_id = tb_item_cat.id&lt;/select&gt;** id是实现的方法名,resultmap对应上面对返回结果的映射,parameterType是返回结果对一个的ben同上**]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[docker的基本用法]]></title>
      <url>%2F2017%2F04%2F21%2Fdocker%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[1:验证是否安装成功 1sudo docker run hello-world 2.重启 123#service docker start //启动#service docker restart //重启#service docker stop //停止 3.版本 1Docker服务对应的版本查看 4.查找镜像 1sudo docker search ubuntu/centos 5.获取镜像 1sudo docker pull ubuntu # 获取 6.查看当前安装的镜像 1sudo docker images 7.运行镜像 1sudo docker run -i -t centos /bin/bash 8.查看当前运行的容器 1sudo docker ps 9.docker help 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ sudo docker # docker 命令帮助Commands: attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像 build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像 commit Create a new image from a container&apos;s changes # 提交当前容器为新的镜像 cp Copy files/folders from the containers filesystem to the host path # 从容器中拷贝指定文件或者目录到宿主机中 create Create a new container # 创建一个新的容器，同 run，但不启动容器 diff Inspect changes on a container&apos;s filesystem # 查看 docker 容器变化 events Get real time events from the server # 从 docker 服务获取容器实时事件 exec Run a command in an existing container # 在已存在的容器上运行命令 export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ] history Show the history of an image # 展示一个镜像形成历史 images List images # 列出系统当前镜像 import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应 export] info Display system-wide information # 显示系统相关信息 inspect Return low-level information on a container # 查看容器详细信息 kill Kill a running container # kill 指定 docker 容器 load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save] login Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器 logout Log out from a Docker registry server # 从当前 Docker registry 退出 logs Fetch the logs of a container # 输出当前容器日志信息 port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端口 pause Pause all processes within a container # 暂停容器 ps List containers # 列出容器列表 pull Pull an image or a repository from the docker registry server # 从docker镜像源服务器拉取指定镜像或者库镜像 push Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker源服务器 restart Restart a running container # 重启运行的容器 rm Remove one or more containers # 移除一个或者多个容器 rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] run Run a command in a new container # 创建一个新的容器并运行一个命令 save Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 load] search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像 start Start a stopped containers # 启动容器 stop Stop a running containers # 停止容器 tag Tag an image into a repository # 给源中镜像打标签 top Lookup the running processes of a container # 查看容器中运行的进程信息 unpause Unpause a paused container # 取消暂停容器 version Show the docker version information # 查看 docker 版本号 wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值Run &apos;docker COMMAND --help&apos; for more information on a command. 10.删除镜像 12docker ps -a 获取容器namedocker rm container_name ``docker rmi xxx1234# 安装nginx1,安装安装wget yum install wget12 sudo apt-get install -y nginx```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybaties逆向工程]]></title>
      <url>%2F2017%2F04%2F21%2FMybaties%2F</url>
      <content type="text"><![CDATA[Mybaties逆向工程反编译数据库1.需要的jar包 12345log4j-1.2.16.jarmybatis-3.2.3.jarmybatis-generator-core-1.3.2.jarmysql-connector-java-5.1.28-bin.jarojdbc14.jar 2.配置的文件,配置文件的名称为 “generatorConfig.xml” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/taotao&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.taotao.pojo&quot; targetProject=&quot;./src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.taotao.mapper&quot; targetProject=&quot;./src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.taotao.mapper&quot; targetProject=&quot;./src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_content&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_content_category&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_cat&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_desc&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_param&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_param_item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_order&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_order_item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_order_shipping&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_user&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 3.逆向工程生成popo和dao持久层 public class GeneratorSqlmap { public void generator() throws Exception{ List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; //指定 逆向工程配置文件 File configFile = new File(&quot;generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); } public static void main(String[] args) throws Exception { try { GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); } catch (Exception e) { e.printStackTrace(); } } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FTP上传下载]]></title>
      <url>%2F2017%2F04%2F17%2FFTP%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[Ftp的上传和下载注意 必须加上编码格式，否则就算上传成功也是 返回fault 123ftpClient.setControlEncoding(&quot;UTF-8&quot;);ftpClient.enterLocalPassiveMode();ftpClient.setFileTransferMode(FTP.STREAM_TRANSFER_MODE); 下载也需要添加,必须在连接上ftp服务器后添加 依赖12345&lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-net.version&#125;&lt;/version&gt; //版本号&lt;/dependency&gt; 源码上传 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Description: 向FTP服务器上传文件 * * @param hostName FTP服务器hostname * @param port FTP服务器端口 * @param username FTP登录账号 * @param password FTP登录密码 * @param basePath FTP服务器基础目录 * @param filePath FTP服务器文件存放路径。例如分日期存放：/2015/01/01。文件的路径为basePath+filePath * @param fileName 上传到FTP服务器上的文件名 * @param inputStream 输入流 * @return 成功返回true，否则返回false */ public static boolean upLoadFile(String hostName, int port, String username, String password,InputStream inputStream, String basePath, String filePath, String fileName) throws IOException &#123; boolean result = false; FTPClient ftpClient = new FTPClient(); try &#123; int reply; ftpClient.connect(hostName, port); ftpClient.login(username, password); reply = ftpClient.getReplyCode(); ftpClient.setControlEncoding(&quot;UTF-8&quot;); ftpClient.enterLocalPassiveMode(); ftpClient.setFileTransferMode(FTP.STREAM_TRANSFER_MODE); if (!FTPReply.isPositiveCompletion(reply)) &#123; ftpClient.disconnect(); return result; &#125; if (!ftpClient.changeWorkingDirectory(basePath + filePath)) &#123; //创建目录 String[] dirs = filePath.split(&quot;/&quot;); String temppath = basePath; for (String dir : dirs) &#123; if (dir == null || &quot;&quot;.equals(dir)) continue; temppath += &quot;/&quot; + dir; if (!ftpClient.changeWorkingDirectory(temppath)) &#123; if (!ftpClient.makeDirectory(temppath)) &#123; return result; &#125; else &#123; ftpClient.changeWorkingDirectory(temppath); &#125; &#125; &#125; &#125; ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); if (!ftpClient.storeFile(fileName, inputStream)) &#123; return result; &#125; ftpClient.logout(); inputStream.close(); result = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ftpClient.isConnected()) &#123; try &#123; ftpClient.disconnect(); &#125; catch (IOException ioe) &#123; &#125; &#125; &#125; return result; &#125; 下载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Description: 从FTP服务器下载文件 * * @param host FTP服务器hostname * @param port FTP服务器端口 * @param username FTP登录账号 * @param password FTP登录密码 * @param remotePath FTP服务器上的相对路径 * @param fileName 要下载的文件名 * @param localPath 下载后保存到本地的路径 * @return */ public static boolean downloadFile(String host, int port, String username, String password, String remotePath, String fileName, String localPath) &#123; boolean result = false; FTPClient ftp = new FTPClient(); try &#123; int reply; ftp.connect(host, port); // 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器 ftp.login(username, password);// 登录 reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) &#123; ftp.disconnect(); return result; &#125; ftp.setControlEncoding(&quot;UTF-8&quot;); ftp.enterLocalPassiveMode(); ftp.setFileTransferMode(FTP.STREAM_TRANSFER_MODE); ftp.changeWorkingDirectory(remotePath);// 转移到FTP服务器目录 FTPFile[] fs = ftp.listFiles(); if (fs == null) return result; for (FTPFile ff : fs) &#123; if (ff.getName().equals(fileName)) &#123; File localFile = new File(localPath + &quot;/&quot; + ff.getName()); OutputStream outputStream = new FileOutputStream(localFile); String ftpPath = remotePath +&quot;/&quot; + ff.getName(); boolean res = ftp.retrieveFile(ftpPath, outputStream); outputStream.close(); if (!res) return result; break; &#125; &#125; ftp.logout(); result = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ftp.isConnected()) &#123; try &#123; ftp.disconnect(); &#125; catch (IOException ioe) &#123; &#125; &#125; &#125; return result; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx做负载均衡]]></title>
      <url>%2F2017%2F04%2F17%2Fnginx%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
      <content type="text"><![CDATA[一． Nginx简介Nginx 是一个开源的高性能的HTTP和反向代理服务器，用于实现资源缓存、web server负载均衡等功能，其特点是占有内存少，并发能力强。使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。是目前最流行的反向代理服务器之一。Nginx反向代理实现Tomcat集群服务器的负载均衡二． Tomcat简介Tomcat是一个免费的开源的纯JAVA开发的Web 应用服务器，可以充当轻量级JAVAEE项目的应用服务器，它还是一个运行Servlet和JSP的web容器。三． 为什么要配置服务器集群服务器集群：是指将很多服务器集中起来一起进行同一种服务，在客户端看来就象是只有一个服务器。 集群可以利用多个计算机进行并行计算从而获得很高的计算速度，也可以用多个计算机做备份，从而使得任何一个机器坏了整个系统还是能正常运行。集群目的：一方面，对于对于日访问量或者并发访问量十分巨大的网站来说，如果只部署一台服务性能十分低下，极有可能对暴风雨般的请求(2016年双十一天猫淘宝几十万的峰值并发请求)招架不住而随时被挂掉，对企业来造成重大损失。有必要多台服务器来分担这种并发请求的压力。另一方面，群集化操作可以减少单点故障数量，就算一台服务器出现了故障，其他服务器正常运行，保证企业的日常运作不受影响，这是非常有必要的事情。并且实现了群集化资源的高可用性。四． 负载均衡对于集群来说，负载均衡意味着当反向代理服务Nginx接受到用户发起的请求后，会把请求按照权重均分到不同的集群服务器上，尽可能让每个服武器均摊请求，减少服务器的压力，提高性能，防止由于高并发导致的服务器宕机或者瘫痪等。应用架构：Nginx反向代理实现Tomcat集群服务器的负载均衡 准备工作：说明：（1）测试环境为windows（2）由于tomcat需要jdk，因此需要安装jdk并配置环境变量（3）下载Nginx并解压(Nginx下载地址：http://nginx.org)（4）下载Tomcat (Tomcat下载地址: http://tomcat.apache.org/download-70.cgi)（5）准备使用两个tomcat服务器，一个Nginx服务器（6）同一个测试web项目(只包含一个jsp页面)打成war包，分别放在tomcat1和tomcat2的webapps目录下服务器名称 测试版本 测试IPNginx Nginx-1.11.13 127.0.0.1:80(默认端口)Tomcat1 7.0+ 127.0.0.1:8080Tomcat2 7.0+ 127.0.0.1:8090主要内容一．搭建Nginx服务器将下载好的Nginx服务器压缩包放到任意盘（比如D盘）进行解压，解压后目录结构为：图（1）Nginx反向代理实现Tomcat集群服务器的负载均衡 成功。此时：在浏览器中输入本机环回地址测试：http://127.0.0.1若出现图（2）,则说明nginx启动成功，服务器正常运行。Nginx反向代理实现Tomcat集群服务器的负载均衡 注意：由于nginx的默认端口为80，因此要确保本机没有其他应用程序占用该端口。至此我们可以进行下一步工作一．搭建Tomcat服务器在搭建Tomcat服务器前，首先需要在安装jdk，因为Tomcat是java写的，而java运行需要jdk。该步骤不是本文讨论的重点，略去。安装好jdk后，需要将Tomcat服务器压缩文件解压两份，分别取名为Tomcat1和Tomcat2。如图（3）tomcat集群服务器所示：Nginx反向代理实现Tomcat集群服务器的负载均衡 在真实环境中，该服务器可以安装到不同的主机中。其中每个服务器目录结构为：图（4）Nginx反向代理实现Tomcat集群服务器的负载均衡 在图（4）的Conf文件夹下面的配置文件server.xml需要将两个tomcat服务的端口改为本机唯一。（若是不同主机则不用修改，默认端口为8080）将tomcat1的server.xml中的服务端口，连接器端口不动（默认）将tomcat2的server.xml中的服务端口改为8006，连接器端口改为依次8090，8010修改server.xml的文件位置为第22行，第70行，第91行：修改后的效果图（5）为：Nginx反向代理实现Tomcat集群服务器的负载均衡 Nginx反向代理实现Tomcat集群服务器的负载均衡 以上步骤完成即可进行下一步一．准备测试项目准备同一个测试web项目，该项目只有一个index.jsp文件。只是在该文件中写一段分别代表两个不同服务器的文字，以示区别：在准备放入tomcat1的项目的index.jsp中写入：“这是四川展谊科技，我部署在tomcat1中！”在准备放入tomcat2的项目的index.jsp中写入：“这是四川展谊科技，我部署在tomcat2中！”每个项目的目录内部结构为：图（6）所示：Nginx反向代理实现Tomcat集群服务器的负载均衡 紧接着把项目打成war包。然后把项目分别复制到两个tomcat对应的wabapps文件夹（见图4）下面。然后分别在两个tomcat图（4）中的bin文件夹找到startup.bat批处理文件，双击启动服务器。接下来主要工作来了一．Nginx配置负载均衡在图（1）的Nginx的conf文件夹下面找到nginx.conf文件，打开并在该文件的htpp指令模块中添加负载均衡指令（具体添加位置见下图（7）的红色标注区域34行和46行）ont-size:9.0000pt;mso-font-kerning:1.0000pt;” &gt;每个项目的目录内部结构为：图（6）所示：Nginx反向代理实现Tomcat集群服务器的负载均衡 在红色区域添第34行和第46行添加如下命令：第34行红色区添加命令如下：upstream lero{ #其中lero命名可以自定义，但要满足基本的命名规则server 127.0.0.1:8080; #tomcat1服务器的地址server 127.0.0.1:8090; #tomcat2服务器的地址}第46行红色区添加命令如下：proxy_pass http://lero; #配置反向代理指向位置完整的配置见下图（8）Nginx反向代理实现Tomcat集群服务器的负载均衡 一．启动服务器修改配置文件后，需要重新启动nginx服务首先在dos命令窗口定位到nginx服务器安装目录（比如：f:nginx-1.11.13）然后输入重启命令为：nginx -s reload（若这种方法无效，建议强行结束进程）如下图（9）：Nginx反向代理实现Tomcat集群服务器的负载均衡 重启tomcat1，tomcat2服务器（点击shutdown.bat批处理文件后，重新点击startup.bat批处理文件即可实现重启），然后在浏览器地址栏输入127.0.0.1/www.sczhanyi.com/访问第一次效果图（10）：Nginx反向代理实现Tomcat集群服务器的负载均衡 访问第二次效果图（11）Nginx反向代理实现Tomcat集群服务器的负载均衡 访问第三次又会把请求发给tomcat1,访问第四次又会把请求发给tomcat2…到此，已实现了nginx反向代理实现tomcat集群服务器的负载均衡配置。每次访问都会轮换切换服务器,把请求分发给不同的服务器！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux上搭建FTP服务器]]></title>
      <url>%2F2017%2F04%2F17%2FLinux%E4%B8%8A%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[ftp服务基本用法ftp简单来说就是存储静态文件的服务器 12345启动 service vsftpd start重启服务 service vsftpd restart开启 service vsftpd start关闭 service vsftpd stop查看状态 service vsftpd status ftp服务器在Linux上的搭建安装步骤1.通过yum来安装vsftpd 1[root@localhost ~]# yum -y install vsftpd 2.设置为开机启动 1[root@localhost ~]# chkconfig vsftpd on 3.把下面几行注释去掉，让其配置生效： 12345local_enable=YESwrite_enable=YESlocal_umask=022pam_service_name=vsftpduserlist_enable=YES 最新的版本,这些都已经开启 4.配置保存后重启vsftpd服务： 1[root@localhost ~]# service vsftpd restart 添加用户1.环境：ftp为vsftp。被设置用户名为test。被限制路径为/home/test 2.创建建用户：在root用户下： 12useradd -d /home/test test #增加用户test，并制定test用户的主目录为/home/test passwd test #为test用户设置密码 3.更改用户相应的权限设置： 123usermod -s /sbin/nologin test #限定用户test不能telnet，只能ftp usermod -s /bin/bash test #用户test恢复正常 usermod -d /home/test test #更改用户test的主目录为/test 5.如果需要允许用户修改密码，但是又没有telnet登录系统的权限： 1usermod -s /usr/bin/passwd test #用户telnet后将直接进入改密界面 6.如果要删除用户，用下面代码： 1234 在root用户下： userdel -r newuser 在普通用户下： sudo userdel -r newuser 因为需要彻底删除用户，所以加上-r的选项，在删除用户的同时一起把这个用户的宿主目录和邮件目录删除。 配置完成没有意外的话,这个用户已经可以访问了,但是根据环境不同可能出现不同的错误 如果出现权限不对.可根据下面的修改权限 123chmod [who] [+ | - | =] [mode] 文件名chmod 777 -R /home/text]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java常用的jar包]]></title>
      <url>%2F2017%2F04%2F12%2Fjava%E5%B8%B8%E7%94%A8%E7%9A%84jar%E5%8C%85%2F</url>
      <content type="text"><![CDATA[Java开发中主要用到的jar包介绍commons-io.jar：可以看成是java.io的扩展，用来帮助进行IO功能开发．它包含三个主要的领域:Utilityclasses-提供一些静态方法来完成公共任务．Filters-提供文件过滤器的各种实现．Streams-提供实用的Stream，reader与writer实现． commons-beanutils.jar：提供对Java反射和自省API的包装，主要提供了对于 JavaBean进行各种操作。commons-digester.jar:它能方便地将XML文档所定义的元素转化为JAVA对象，其实它的用法有点象栈(当然内在的原理就是那个古老的东西,只是提供了更高一层的封装)。 commons-lang.jar:它扩展了标准 java.langAPI，增加了字符串操作方法、基本数值方法、对象反射、创建和串行化以及System属性。它还包含一个可继承的enum类型、对多种嵌套的Exception类型的支持、对java.util.Date的增强以及用于构建方法的实用程序，例如自动生成 toString()的结果、自动实现hashCode()和equals()方法、数组操作、枚举、日期和时间的处理等等。ArrayUtils–用于对数组的操作，如添加、查找、删除、子数组、倒序、元素类型转换等；BitField–用于操作位元，提供了一些方便而安全的方法；BooleanUtils–用于操作和转换boolean或者Boolean及相应的数组；CharEncoding–包含了Java环境支持的字符编码，提供是否支持某种编码的判断；CharRange–用于设定字符范围并做相应检查；CharSet–用于设定一组字符作为范围并做相应检查；CharSetUtils–用于操作CharSet；CharUtils–用于操作char值和Character对象；ClassUtils–用于对Java类的操作，不使用反射；ObjectUtils–用于操作Java对象，提供null安全的访问和其他一些功能；RandomStringUtils–用于生成随机的字符串；SerializationUtils–用于处理对象序列化，提供比一般Java序列化更高级的处理能力；StringEscapeUtils–用于正确处理转义字符，产生正确的Java、JavaScript、HTML、XML和SQL代码；StringUtils–处理String的核心类，提供了相当多的功能；SystemUtils–在java.lang.System基础上提供更方便的访问，如用户路径、Java版本、时区、操作系统等判断；Validate–提供验证的操作，有点类似assert断言；WordUtils–用于处理单词大小写、换行等。commons-codec.jar：包含一些通用的编码解码算法。包括一些语音编码器，Hex,Base64, 以及URLencoder。 commons-collections.jar：提供一个类包来扩展和增加标准的JavaCollection框架。Bag接口：适用于包含一个对象的多个拷贝的集合Buffer接口：适用于具有顺序的集合类，例如FIFOs(先进先出)BidiMap(双向映射)：可以通过值查找键，也可以通过键查找值Map迭代器：提供了对映射的快速迭代对类型检查进行了封装，确保特定类的实例可以被添加到集合中对转换进行了封装，将集合中的对象转换成被加入时的类型对集合进行组合，使多个集合看起来就像一个集合一样有序映射和set，保持元素添加时的顺序，包括一个基于LRU的map标识映射可以给予对象的==来比较对象，而不是基于equals方法引用映射可以允许键and/or值可以有控制的进行回收很多比较器的实现很多迭代器的实现从数组或者枚举到集合的适配器用来测试或者创建典型set理论的集合属性，例如与、或、闭包 commons-dbutil.jar:对传统操作数据库的类进行二次封装，可以把结果集转化成List(1)org.apache.commons.dbutilsDbUtils : 提供如关闭连接、装载JDBC驱动程序等常规工作的工具类QueryRunner: 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。QueryLoader: 属性文件加载器，主要用于加载属性文件中的SQL到内存中。(2)org.apache.commons.dbutils.handlersArrayHandler：将ResultSet中第一行的数据转化成对象数组ArrayListHandler将ResultSet中所有的数据转化成List，List中存放的是Object[]BeanHandler：将ResultSet中第一行的数据转化成类对象BeanListHandler：将ResultSet中所有的数据转化成List，List中存放的是类对象ColumnListHandler：将ResultSet中某一列的数据存成List，List中存放的是Object对象KeyedHandler：将ResultSet中存成映射，key为某一列对应为Map。Map中存放的是数据MapHandler：将ResultSet中第一行的数据存成Map映射MapListHandler：将ResultSet中所有的数据存成List。List中存放的是MapScalarHandler：将ResultSet中一条记录的其中某一列的数据存成Object java开发中主要用到的jar包总结axis.jar:SOAP引擎包jaxrpc.jar:Axis运行所需要的组件包saaj.jar:创建到端点的点到点连接的方法、创建并处理SOAP消息和附件的方法，以及接收和处理SOAP错误的方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139wsdl4j-1.5.1.jar:Axis运行所需要的组件包activation.jar:JAF框架的jar包annotations-api.jar:使用注解所需jarant.jar:用于自动化调用程序完成项目的编译，打包，测试等aopalliance-1.0.jar:支持spring AOPasm-2.2.3.jar:ASM字节码库asm-commons-2.2.3.jar:ASM字节码库asm-util-2.2.3.jar:Java字节码操纵和分析框架aspectjrt.jar:处理事务和AOP所需的包aspectjweaver.jar:处理事务和AOP所需的包axiom-api-1.2.7.jar:Axis 对象模型axiom-impl-1.2.7.jar:Axis 对象模型bcprov-jdk15-140.jar:基于java1.5 的加密算法实现bfmclientmodel.jar:使用WebSphere所需jar包bpcclientcore.jar:使用WebSphere所需jar包bpe137650.jar:提供远程访问BPE容器的实现。 bsh-2.0b4.jar:解决负载逻辑运算c3p0-0.9.0.jar:开放源代码的JDBC连接池cglib-nodep-2.1_3.jar:Spring中自动代理所需jar包cobertura.jar:测量测试覆盖率commons-beanutils-1.7.0.jar:动态的获取/设值Java Bean的属性commons-chain-1.1.jar:实现责任链设计模式的Java 类库commons-codec-1.3.jar:用来处理常用的编码方法的工具类包，例如DES、SHA1、MD5、Base64等等commons-collections-3.1.jar:对标准java Collection的扩展commons-collections.jar:对标准java Collection的扩展commons-discovery-0.2.jar:用来发现、查找和实现可插入式接口，提供一些一般类实例化、单件的生命周期管理的常用方法.db2jcc.jarjava连接DB2所需jarcommons-digester-1.8.jar:用于处理struts-config.xml配置文件commons-fileupload-1.1.1.jar:struts上传文件commons-httpclient-3.1.jar:用来简化HTTP客户端与服务器端进行各种通信编程实现commons-io-1.1.jar:针对java.io.InputStream和Reader进行了扩展commons-lang-2.4.jar:对java.lang.*的扩展commons-logging-1.1.1.jar:日志包commons-pool-1.3.jar:实现对象池化框架commons-validator-1.3.1.jar:用来把验证规则程序提取出来，以供重复使用db2jcc_license_cu.jar:java:连接DB2所需jardom4j-1.6.1.jar:解析XMLehcache-1.2.4.jar:hibernate的二级缓存如果用ehcache的时候需要此jar包emf.jar:基于Eclipse的模型框架ezmorph-1.0.6.jar:使用JSON所需的jar包FastInfoset-1.2.2.jar:使用WebService所需的jar包freemarker-2.3.8.jar:Strus2支持的一种表现层框架geronimo-activation_1.1_spec-1.0.2.jar:Apache Geronimo所带jar包，geronimo-annotation_1.0_spec-1.1.1.jar:Apache Geronimo所带jar包geronimo-javamail_1.4_spec-1.3.jar:Apache Geronimo所带jar包geronimo-jaxws_2.1_spec-1.0.jar:Apache Geronimo所带jar包geronimo-jms_1.1_spec-1.1.1.jar:Apache Geronimo所带jar包geronimo-servlet_2.5_spec-1.2.jar:Apache Geronimo所带jar包geronimo-stax-api_1.0_spec-1.0.1.jar:Apache Geronimo所带jar包hibernate3.jar:Hibernate3的核心jar包htmclientmodel.jar:使用WebSphere所需jar包jakarta-oro.jar:一套文本处理工具，提供per15.0兼容的表达式，AWK-like表达式，Glob表达式。javassist.jar:Javassist 字节码解释器jaxb-api-2.1.jar:使用WebService所需的jar包jaxb-impl-2.1.7.jar:使用CXF所需jar包jaxb-xjc-2.1.7.jar:使用CXF所需jar包jaxen-1.1.1.jar:解析XMLjcifs-1.2.22.jar:实现单点登陆jdom2-1.0.jar:解析XMLjdom-1.0.jar:解析XMLjettison-1.0.1.jar:使用CXF所需jar包jetty-6.1.9.jar:Jetty Http服务器jarjetty-util-6.1.9.jar:Jetty Http服务器jarjra-1.0-alpha-4.jar:使用CXF所需jar包js-1.6R7.jar:使用CXF所需jar包json-lib-2.2.3-jdk13.jar:使用JSON所需的jar包jsonplugin-0.25.jar:strus2的JSON插件jsr311-api-0.8.jar:使用CXF所需jar包jstl.jar:JSTL标签库jta.jar:标准的 JAVA 事务处理接口junit.jar:用于单元测试jxl.jar:通过java操作excel表格的工具类库ldap.jar:JNDI目录服务和LDAO服务器所需的jarldapbp.jar:JNDI目录服务和LDAO服务器所需的jarlog4j-1.2.15.jar:提供日志功能mail.jar:java发送邮件jar包neethi-2.0.4.jar:使用CXF所需jar包odmg-3.0.jar:ODMG是一个ORM的规范，Hibernate实现了ODMG规范，这是一个核心的库ognl-2.6.11.jar:struts2中OGNL语言ojdbc14.jar:Oracle数据库驱动包opensaml-1.1.jar:使用CXF所需jar包oro-2.0.8.jar:Validator框架所需的jar包oscache-2.1.jar:Java 对象的缓存工具poi-3.1-FINAL-20080629.jar:操作exce所需jar包poi-contrib-3.1-FINAL-20080629.jar:操作exce所需jar包poi-ooxml-3.6-20091214.jar:提供对office的word、excel、visio及ppt的操作poi-ooxml-schemas-3.6-20091214.jar:提供对office的word、excel、visio及ppt的操作poi-scratchpad-3.1-FINAL-20080629.jar:提供对office的word、excel、visio及ppt的操作processCommon.jarIBM WebSphere:运行所需jarProcessCommonLibrary.jarIBM WebSphere:运行所需jarprocessIdentity.jarIBM WebSphere:运行所需jarProcessInformation.jar:进程监视软件包proxool-0.9.1.jar:数据库连接池proxool-cglib.jar:数据库连接池quartz-1.6.0.jar:开源作业调度框架saaj-api-1.3.jar:使用axis所需的jarsaaj-impl-1.3.2.jar:使用axis所需的jarserializer-2.7.1.jar:XML序列化slf4j-jdk14-1.5.6.jar:整合各种日志框架的工具spring208.jar:spring核心框架spring-ldap-1.2-RC1.jar:spring下LDAPspring-mock.jar:spring的测试框架standard.jar:使用JSTL标签库所需的jarstax-api-1.0.1.jar:解析XMLstruts2-core-2.0.14.jar:struts2核心jarstruts2-spring-plugin-2.0.6.jar:struts2整合Spring所需jartaglibs-datetime.jar:Apache开源组织提供标签库，用于格式化日期。taglibs-mailer.jar:用于发送邮件taglibs-string.jar:Apache开源组织提供标签库，用于对String的操作。task137650.jar:Portal技术在SOA系统集成应用中实现所需的jarutility.jar:Apache开源组织提供标签库velocity-1.5.jar:一个免费的开源模板框架wsdl4j-1.6.2.jar:用来解析服务的WSDl文件wss4j-1.5.4.jar:创建CXF所需jarwstx-asl-3.2.6.jar:创建CXF所需jarxbean-spring-2.8.jar:使用xfire所需jarxerces-2.6.2.jar:XML解析器xfire-all-1.2.6.jar:用于实现WebServiceXmlSchema-1.1.jar:使用xfire所需jarxwork-2.0.7.jar:WebWork核心jar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-web基本应用]]></title>
      <url>%2F2017%2F04%2F11%2Fjava-web%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Spring Validation（使用Hibernate Validator）判断表单 数据是否空,大小,email…..1、需要的jar包hibernate-validator.5.1.3.Final.jar validation-api.1.1.0.Final.jar 在spring3之后，任何支持JSR303的validator（如Hibernate Validator）都可以通过简单配置引入，只需要在配置xml中加入，这时validatemessage的属性文件默认为classpath下的ValidationMessages.properties：12&lt;!-- support JSR303 annotation if JSR 303 validation present on classpath --&gt;&lt;mvc:annotation-driven /&gt; 注解123456789101112131415161718192021Bean Validation 中内置的 constraint @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 使用在对象中 12345public class Customer &#123; 7 8 @NotEmpty //make sure name is not empty 9 String name;10 在controller中 12345678910111213public class SignUpController &#123;14 15 @RequestMapping(value = &quot;/signup&quot;, method = RequestMethod.POST)16 public String addCustomer(@Valid Customer customer,(这里使用) BindingResult result) &#123;17 18 if (result.hasErrors()) &#123;19 return &quot;SignUpForm&quot;;20 &#125; else &#123;21 return &quot;Done&quot;;22 &#125;23 24 &#125; 文件上传]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ruby脚本进行提交git或git私有库]]></title>
      <url>%2F2017%2F04%2F10%2FRuby%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E6%8F%90%E4%BA%A4git%2F</url>
      <content type="text"><![CDATA[Ruby脚本进行提交git和git私有库简单的ruby脚本 提交git本地 提交git远程 制作好远程私有库,提交到远程私有库 制作好远程公有库github,提交到github github:https://github.com/winsions/RubyToGit.git 用法把文件夹中的 fastlane文件复制到项目的根目录 提交到git (本地和远程) 复制:提到本地git1文件 或者提到远程git2文件cd到项目执行 下面命令 1fastlane ManagerLib message:本次所修改的描述 提交私有库或者公有库 复制:提交到公有库github3文件 或者提交到私有库4文件cd到项目执行 下面命令 1fastlane ManagerLib tag:0.1.0(标签号) target:项目的名字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[有用的网站都在这里]]></title>
      <url>%2F2017%2F04%2F10%2F%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%2F</url>
      <content type="text"><![CDATA[真的有用各种操作系统 工具什么样的都有http://www.itellyou.cn/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo的简单使用]]></title>
      <url>%2F2017%2F04%2F10%2Fhexo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[hexo的简单使用创建新博客的cd到hexo的根目录文件1hexo new post &quot;hexo的简单使用&quot; (标题) 分布1hexo g 调试模式1hexo s --debug 启动服务1hexo s 上传github1hexo d]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git的简单使用]]></title>
      <url>%2F2017%2F04%2F06%2Fgit%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[git的简单使用查看远程库信息，使用 1git remote -v; 本地新建的分支如果不推送到远程，对其他人就是不可见的; 从本地推送分支，使用 12git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交; 在本地创建和远程分支对应的分支，使用 本地和远程分支的名称最好一致; 1git checkout -b branch-name origin/branch-name， 建立本地分支和远程分支的关联，使用 1git branch --set-upstream branch-name origin/branch-name; 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 1git pull origin master 分支查看当前在哪个分支1git branch 切换分支1git checkout develop 合并分支1git merge --no-ff develop 创建分支 1git checkout -b feature-x(新分支的名字) develop(基础分支) 删除分支1git branch -d feature-x 删除本次所有的修改,回到这一版本最干净的状态12git clean -df (删除变异的临时文件)git reset --hard (删除修改的文件) 如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。12git push origin test:master // 提交本地test分支作为远程的master分支git push origin test:test // 提交本地test分支作为远程的test分支 1git push --set-upstream origin develop 提交本地分支到远程新的分支 如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。 1git push origin :test // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心 Git回滚分支首先备份当前的master分支，防止回滚失败。 从origin master中新建一个分支，名称随便，比如，master_backup。 备份完成后，将master回滚到指定的版本,注意这个地方，是将本地的master分支回滚到指定的版本1git reset --hard commit-id 回滚本地master完成后，将回滚后的代码push到远端master，覆盖远端master分支。方法为：通过git命令，必须通过命令来，sourcetree的方式不可行。 1git push -f origin master。必须有-f，表示强制的意思。 此时，会要求用户输入远端仓库的用户名和密码，用于确认当前用户具有-f的权限。 push成功后，就可以删除备份的master了。sourcetree的方式也是不可以的1git branch -D master_backup tag 加标签添加标签 12git tag 0.1.0;git tag -a v0.1.2 -m “0.1.2版本” 发布标签12git push origin v0.1.2git push --tags 切换1git checkout [tagname] 删除1git tag -d v0.1.2 # 删除标签 删除远程标签1git push origin :refs/tags/标签名 git远程连接git删除远程连接1git remote rm origin 添加远程连接1git remote add origin 远程仓库地址 1git push --set-upstream origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从iOS转战JavaWeb]]></title>
      <url>%2F2017%2F04%2F01%2F%E4%BB%8EiOS%E8%BD%AC%E6%88%98JavaWeb%2F</url>
      <content type="text"><![CDATA[需要持续不段的学习才行hexo的简单命令12345678910111213hexo new&quot;postName&quot; #新建文章hexo new page&quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[出游小记]]></title>
      <url>%2F2017%2F04%2F01%2Fhello-world%2F</url>
      <content type="text"><![CDATA[贸然的一次出行突然间的放松电脑已经成为我的习惯，突然发现自己好像少了某些重要的东西–电脑，原来已经三天没摸电脑了，电脑已成为我生活的一部分了。但是出游让我学到了其他的存在。 生活随心长时间的办公室生活已经让我不知道改怎么释放自己，总是很在乎别人怎么看，好像自己是在为别人而活。看到一对夫妻在公园玩，高高兴兴的啃着北京方便面，然而有些人却扯着嘴角在笑，他们依然在到处游玩，不要为别人的想法而影响自己，在不影响公共秩序的情况下，做我们自己想做的事情，让自己开心的事情，何乐不为呢。看到某一个逗逼，把吃饭盒放在一个大酒缸的前面，旁边人来人往，自己放了5毛钱，让我给他拍照。我当时的第一想法是：丢不丢人啊，这么多人看着，照片我都不想拍，可是别人都不认识我，我怕什么呢。当然这只是一个最简单的解释，我们玩我们自己的，有没有影响到别人，管他怎么看呢，我开心就好，出来玩嘛本身就图个开心。其实我也想玩很多，但就是怕别人看到笑话，而不敢做，这不是违背了我们出来玩的初衷吗？这并不是没心没肺，只是在生活中腰做真实的自己。关心身边的人，这次被一个向导无微不至的照顾，让我无地自容啊，此处省略一万字。。。。。。 沟通这是人与人的社会，沟通无处不在，如果只有你一个人倒也显得无趣。鼓起勇气只要能开个头，就又可能聊下去，可能又多了一个朋友，或者增长一下见闻，毕竟每一个人的经历都是不同的。比如在飞机上，没手机可玩，大家要么睡觉，要么双眼无神的看着远方，其实和身边的人聊一聊，时间过的也挺快呢，还能了解一下别人的人经历，也有可能就多了一个人生中的朋友，说的庸俗一点，也有可能是你下一个发财的机会。 小结没有文彩，就当记一下流水账喽，发现自己的缺点，就要努力去攻克他，早上走向人生巅峰，赢取心爱的她。]]></content>
    </entry>

    
  
  
</search>
