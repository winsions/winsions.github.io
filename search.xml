<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Mybaties的基础用法]]></title>
      <url>%2F2017%2F04%2F24%2FMybaties%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Mybaties的基础用法基础用法1.通过条件查询先创建example,添加条件 1234567TbItemExample tbItemExample = new TbItemExample(); TbItemExample.Criteria criteria = tbItemExample.createCriteria(); criteria.andIdEqualTo(id); List&lt;TbItem&gt; tbItems = tbItemMapper.selectByExample(tbItemExample); item = tbItems.get(0); 2.分页插件的基本使用 在调价查询前,加上 1PageHelper.startPage(page, rows); page是页数,rows是每页显示的条数 总页数,查询之后 12PageInfo&lt;TbItem&gt; pageInfo = new PageInfo&lt;TbItem&gt;(tbItems); **总页数** pageInfo.getTotal(); 3.基本的查询 insert delete update select 高级用法1.复杂的表结构,多表关联 在map.java中添加新的方法 在对应的XML文件中实现这个方法 1234567891011121314 1.添加对结果的映射 &lt;resultMap id=&quot;ResultMapAndItemName&quot; type=&quot;com.taotao.pojo.TbItemParam&quot; extends=&quot;BaseResultMap&quot;&gt; &lt;result column=&quot;param_data&quot; property=&quot;paramData&quot; jdbcType=&quot;LONGVARCHAR&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;itemCatName&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/resultMap&gt; **column是数据库中字段的名字,property是表中的属性的名字.type是返回结果对一个的ben** 2.实现map中的方法 &lt;select id=&quot;selectItemParamAndItemCat&quot; resultMap=&quot;ResultMapAndItemName&quot; parameterType=&quot;com.taotao.pojo.TbItemParam&quot;&gt;SELECT tb_item_param.id,item_cat_id,param_data,tb_item_param.created,tb_item_param.updated,name from tb_item_paramLEFT join tb_item_cat on tb_item_param.item_cat_id = tb_item_cat.id&lt;/select&gt;** id是实现的方法名,resultmap对应上面对返回结果的映射,parameterType是返回结果对一个的ben同上**]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[docker的基本用法]]></title>
      <url>%2F2017%2F04%2F21%2Fdocker%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[1:验证是否安装成功 1sudo docker run hello-world 2.重启 123#service docker start //启动#service docker restart //重启#service docker stop //停止 3.版本 1Docker服务对应的版本查看 4.查找镜像 1sudo docker search ubuntu/centos 5.获取镜像 1sudo docker pull ubuntu # 获取 6.查看当前安装的镜像 1sudo docker images 7.运行镜像 1sudo docker run -i -t centos /bin/bash 8.查看当前运行的容器 1sudo docker ps 9.docker help 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ sudo docker # docker 命令帮助Commands: attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像 build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像 commit Create a new image from a container&apos;s changes # 提交当前容器为新的镜像 cp Copy files/folders from the containers filesystem to the host path # 从容器中拷贝指定文件或者目录到宿主机中 create Create a new container # 创建一个新的容器，同 run，但不启动容器 diff Inspect changes on a container&apos;s filesystem # 查看 docker 容器变化 events Get real time events from the server # 从 docker 服务获取容器实时事件 exec Run a command in an existing container # 在已存在的容器上运行命令 export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ] history Show the history of an image # 展示一个镜像形成历史 images List images # 列出系统当前镜像 import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应 export] info Display system-wide information # 显示系统相关信息 inspect Return low-level information on a container # 查看容器详细信息 kill Kill a running container # kill 指定 docker 容器 load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save] login Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器 logout Log out from a Docker registry server # 从当前 Docker registry 退出 logs Fetch the logs of a container # 输出当前容器日志信息 port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端口 pause Pause all processes within a container # 暂停容器 ps List containers # 列出容器列表 pull Pull an image or a repository from the docker registry server # 从docker镜像源服务器拉取指定镜像或者库镜像 push Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker源服务器 restart Restart a running container # 重启运行的容器 rm Remove one or more containers # 移除一个或者多个容器 rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] run Run a command in a new container # 创建一个新的容器并运行一个命令 save Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 load] search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像 start Start a stopped containers # 启动容器 stop Stop a running containers # 停止容器 tag Tag an image into a repository # 给源中镜像打标签 top Lookup the running processes of a container # 查看容器中运行的进程信息 unpause Unpause a paused container # 取消暂停容器 version Show the docker version information # 查看 docker 版本号 wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值Run &apos;docker COMMAND --help&apos; for more information on a command. 10.删除镜像 12docker ps -a 获取容器namedocker rm container_name ``docker rmi xxx1234# 安装nginx1,安装安装wget yum install wget12 sudo apt-get install -y nginx```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybaties逆向工程]]></title>
      <url>%2F2017%2F04%2F21%2FMybaties%2F</url>
      <content type="text"><![CDATA[Mybaties逆向工程反编译数据库1.需要的jar包 12345log4j-1.2.16.jarmybatis-3.2.3.jarmybatis-generator-core-1.3.2.jarmysql-connector-java-5.1.28-bin.jarojdbc14.jar 2.配置的文件,配置文件的名称为 “generatorConfig.xml” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/taotao&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.taotao.pojo&quot; targetProject=&quot;./src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.taotao.mapper&quot; targetProject=&quot;./src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.taotao.mapper&quot; targetProject=&quot;./src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_content&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_content_category&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_cat&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_desc&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_param&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_item_param_item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_order&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_order_item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_order_shipping&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;tb_user&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 3.逆向工程生成popo和dao持久层 public class GeneratorSqlmap { public void generator() throws Exception{ List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; //指定 逆向工程配置文件 File configFile = new File(&quot;generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); } public static void main(String[] args) throws Exception { try { GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); } catch (Exception e) { e.printStackTrace(); } } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FTP上传下载]]></title>
      <url>%2F2017%2F04%2F17%2FFTP%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[Ftp的上传和下载注意 必须加上编码格式，否则就算上传成功也是 返回fault 123ftpClient.setControlEncoding(&quot;UTF-8&quot;);ftpClient.enterLocalPassiveMode();ftpClient.setFileTransferMode(FTP.STREAM_TRANSFER_MODE); 下载也需要添加,必须在连接上ftp服务器后添加 依赖12345&lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-net.version&#125;&lt;/version&gt; //版本号&lt;/dependency&gt; 源码上传 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Description: 向FTP服务器上传文件 * * @param hostName FTP服务器hostname * @param port FTP服务器端口 * @param username FTP登录账号 * @param password FTP登录密码 * @param basePath FTP服务器基础目录 * @param filePath FTP服务器文件存放路径。例如分日期存放：/2015/01/01。文件的路径为basePath+filePath * @param fileName 上传到FTP服务器上的文件名 * @param inputStream 输入流 * @return 成功返回true，否则返回false */ public static boolean upLoadFile(String hostName, int port, String username, String password,InputStream inputStream, String basePath, String filePath, String fileName) throws IOException &#123; boolean result = false; FTPClient ftpClient = new FTPClient(); try &#123; int reply; ftpClient.connect(hostName, port); ftpClient.login(username, password); reply = ftpClient.getReplyCode(); ftpClient.setControlEncoding(&quot;UTF-8&quot;); ftpClient.enterLocalPassiveMode(); ftpClient.setFileTransferMode(FTP.STREAM_TRANSFER_MODE); if (!FTPReply.isPositiveCompletion(reply)) &#123; ftpClient.disconnect(); return result; &#125; if (!ftpClient.changeWorkingDirectory(basePath + filePath)) &#123; //创建目录 String[] dirs = filePath.split(&quot;/&quot;); String temppath = basePath; for (String dir : dirs) &#123; if (dir == null || &quot;&quot;.equals(dir)) continue; temppath += &quot;/&quot; + dir; if (!ftpClient.changeWorkingDirectory(temppath)) &#123; if (!ftpClient.makeDirectory(temppath)) &#123; return result; &#125; else &#123; ftpClient.changeWorkingDirectory(temppath); &#125; &#125; &#125; &#125; ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); if (!ftpClient.storeFile(fileName, inputStream)) &#123; return result; &#125; ftpClient.logout(); inputStream.close(); result = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ftpClient.isConnected()) &#123; try &#123; ftpClient.disconnect(); &#125; catch (IOException ioe) &#123; &#125; &#125; &#125; return result; &#125; 下载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Description: 从FTP服务器下载文件 * * @param host FTP服务器hostname * @param port FTP服务器端口 * @param username FTP登录账号 * @param password FTP登录密码 * @param remotePath FTP服务器上的相对路径 * @param fileName 要下载的文件名 * @param localPath 下载后保存到本地的路径 * @return */ public static boolean downloadFile(String host, int port, String username, String password, String remotePath, String fileName, String localPath) &#123; boolean result = false; FTPClient ftp = new FTPClient(); try &#123; int reply; ftp.connect(host, port); // 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器 ftp.login(username, password);// 登录 reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) &#123; ftp.disconnect(); return result; &#125; ftp.setControlEncoding(&quot;UTF-8&quot;); ftp.enterLocalPassiveMode(); ftp.setFileTransferMode(FTP.STREAM_TRANSFER_MODE); ftp.changeWorkingDirectory(remotePath);// 转移到FTP服务器目录 FTPFile[] fs = ftp.listFiles(); if (fs == null) return result; for (FTPFile ff : fs) &#123; if (ff.getName().equals(fileName)) &#123; File localFile = new File(localPath + &quot;/&quot; + ff.getName()); OutputStream outputStream = new FileOutputStream(localFile); String ftpPath = remotePath +&quot;/&quot; + ff.getName(); boolean res = ftp.retrieveFile(ftpPath, outputStream); outputStream.close(); if (!res) return result; break; &#125; &#125; ftp.logout(); result = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ftp.isConnected()) &#123; try &#123; ftp.disconnect(); &#125; catch (IOException ioe) &#123; &#125; &#125; &#125; return result; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx做负载均衡]]></title>
      <url>%2F2017%2F04%2F17%2Fnginx%E5%81%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
      <content type="text"><![CDATA[一． Nginx简介Nginx 是一个开源的高性能的HTTP和反向代理服务器，用于实现资源缓存、web server负载均衡等功能，其特点是占有内存少，并发能力强。使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。是目前最流行的反向代理服务器之一。Nginx反向代理实现Tomcat集群服务器的负载均衡二． Tomcat简介Tomcat是一个免费的开源的纯JAVA开发的Web 应用服务器，可以充当轻量级JAVAEE项目的应用服务器，它还是一个运行Servlet和JSP的web容器。三． 为什么要配置服务器集群服务器集群：是指将很多服务器集中起来一起进行同一种服务，在客户端看来就象是只有一个服务器。 集群可以利用多个计算机进行并行计算从而获得很高的计算速度，也可以用多个计算机做备份，从而使得任何一个机器坏了整个系统还是能正常运行。集群目的：一方面，对于对于日访问量或者并发访问量十分巨大的网站来说，如果只部署一台服务性能十分低下，极有可能对暴风雨般的请求(2016年双十一天猫淘宝几十万的峰值并发请求)招架不住而随时被挂掉，对企业来造成重大损失。有必要多台服务器来分担这种并发请求的压力。另一方面，群集化操作可以减少单点故障数量，就算一台服务器出现了故障，其他服务器正常运行，保证企业的日常运作不受影响，这是非常有必要的事情。并且实现了群集化资源的高可用性。四． 负载均衡对于集群来说，负载均衡意味着当反向代理服务Nginx接受到用户发起的请求后，会把请求按照权重均分到不同的集群服务器上，尽可能让每个服武器均摊请求，减少服务器的压力，提高性能，防止由于高并发导致的服务器宕机或者瘫痪等。应用架构：Nginx反向代理实现Tomcat集群服务器的负载均衡 准备工作：说明：（1）测试环境为windows（2）由于tomcat需要jdk，因此需要安装jdk并配置环境变量（3）下载Nginx并解压(Nginx下载地址：http://nginx.org)（4）下载Tomcat (Tomcat下载地址: http://tomcat.apache.org/download-70.cgi)（5）准备使用两个tomcat服务器，一个Nginx服务器（6）同一个测试web项目(只包含一个jsp页面)打成war包，分别放在tomcat1和tomcat2的webapps目录下服务器名称 测试版本 测试IPNginx Nginx-1.11.13 127.0.0.1:80(默认端口)Tomcat1 7.0+ 127.0.0.1:8080Tomcat2 7.0+ 127.0.0.1:8090主要内容一．搭建Nginx服务器将下载好的Nginx服务器压缩包放到任意盘（比如D盘）进行解压，解压后目录结构为：图（1）Nginx反向代理实现Tomcat集群服务器的负载均衡 成功。此时：在浏览器中输入本机环回地址测试：http://127.0.0.1若出现图（2）,则说明nginx启动成功，服务器正常运行。Nginx反向代理实现Tomcat集群服务器的负载均衡 注意：由于nginx的默认端口为80，因此要确保本机没有其他应用程序占用该端口。至此我们可以进行下一步工作一．搭建Tomcat服务器在搭建Tomcat服务器前，首先需要在安装jdk，因为Tomcat是java写的，而java运行需要jdk。该步骤不是本文讨论的重点，略去。安装好jdk后，需要将Tomcat服务器压缩文件解压两份，分别取名为Tomcat1和Tomcat2。如图（3）tomcat集群服务器所示：Nginx反向代理实现Tomcat集群服务器的负载均衡 在真实环境中，该服务器可以安装到不同的主机中。其中每个服务器目录结构为：图（4）Nginx反向代理实现Tomcat集群服务器的负载均衡 在图（4）的Conf文件夹下面的配置文件server.xml需要将两个tomcat服务的端口改为本机唯一。（若是不同主机则不用修改，默认端口为8080）将tomcat1的server.xml中的服务端口，连接器端口不动（默认）将tomcat2的server.xml中的服务端口改为8006，连接器端口改为依次8090，8010修改server.xml的文件位置为第22行，第70行，第91行：修改后的效果图（5）为：Nginx反向代理实现Tomcat集群服务器的负载均衡 Nginx反向代理实现Tomcat集群服务器的负载均衡 以上步骤完成即可进行下一步一．准备测试项目准备同一个测试web项目，该项目只有一个index.jsp文件。只是在该文件中写一段分别代表两个不同服务器的文字，以示区别：在准备放入tomcat1的项目的index.jsp中写入：“这是四川展谊科技，我部署在tomcat1中！”在准备放入tomcat2的项目的index.jsp中写入：“这是四川展谊科技，我部署在tomcat2中！”每个项目的目录内部结构为：图（6）所示：Nginx反向代理实现Tomcat集群服务器的负载均衡 紧接着把项目打成war包。然后把项目分别复制到两个tomcat对应的wabapps文件夹（见图4）下面。然后分别在两个tomcat图（4）中的bin文件夹找到startup.bat批处理文件，双击启动服务器。接下来主要工作来了一．Nginx配置负载均衡在图（1）的Nginx的conf文件夹下面找到nginx.conf文件，打开并在该文件的htpp指令模块中添加负载均衡指令（具体添加位置见下图（7）的红色标注区域34行和46行）ont-size:9.0000pt;mso-font-kerning:1.0000pt;” &gt;每个项目的目录内部结构为：图（6）所示：Nginx反向代理实现Tomcat集群服务器的负载均衡 在红色区域添第34行和第46行添加如下命令：第34行红色区添加命令如下：upstream lero{ #其中lero命名可以自定义，但要满足基本的命名规则server 127.0.0.1:8080; #tomcat1服务器的地址server 127.0.0.1:8090; #tomcat2服务器的地址}第46行红色区添加命令如下：proxy_pass http://lero; #配置反向代理指向位置完整的配置见下图（8）Nginx反向代理实现Tomcat集群服务器的负载均衡 一．启动服务器修改配置文件后，需要重新启动nginx服务首先在dos命令窗口定位到nginx服务器安装目录（比如：f:nginx-1.11.13）然后输入重启命令为：nginx -s reload（若这种方法无效，建议强行结束进程）如下图（9）：Nginx反向代理实现Tomcat集群服务器的负载均衡 重启tomcat1，tomcat2服务器（点击shutdown.bat批处理文件后，重新点击startup.bat批处理文件即可实现重启），然后在浏览器地址栏输入127.0.0.1/www.sczhanyi.com/访问第一次效果图（10）：Nginx反向代理实现Tomcat集群服务器的负载均衡 访问第二次效果图（11）Nginx反向代理实现Tomcat集群服务器的负载均衡 访问第三次又会把请求发给tomcat1,访问第四次又会把请求发给tomcat2…到此，已实现了nginx反向代理实现tomcat集群服务器的负载均衡配置。每次访问都会轮换切换服务器,把请求分发给不同的服务器！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux上搭建FTP服务器]]></title>
      <url>%2F2017%2F04%2F17%2FLinux%E4%B8%8A%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[ftp服务基本用法ftp简单来说就是存储静态文件的服务器 12345启动 service vsftpd start重启服务 service vsftpd restart开启 service vsftpd start关闭 service vsftpd stop查看状态 service vsftpd status ftp服务器在Linux上的搭建安装步骤1.通过yum来安装vsftpd 1[root@localhost ~]# yum -y install vsftpd 2.设置为开机启动 1[root@localhost ~]# chkconfig vsftpd on 3.把下面几行注释去掉，让其配置生效： 12345local_enable=YESwrite_enable=YESlocal_umask=022pam_service_name=vsftpduserlist_enable=YES 最新的版本,这些都已经开启 4.配置保存后重启vsftpd服务： 1[root@localhost ~]# service vsftpd restart 添加用户1.环境：ftp为vsftp。被设置用户名为test。被限制路径为/home/test 2.创建建用户：在root用户下： 12useradd -d /home/test test #增加用户test，并制定test用户的主目录为/home/test passwd test #为test用户设置密码 3.更改用户相应的权限设置： 123usermod -s /sbin/nologin test #限定用户test不能telnet，只能ftp usermod -s /bin/bash test #用户test恢复正常 usermod -d /home/test test #更改用户test的主目录为/test 5.如果需要允许用户修改密码，但是又没有telnet登录系统的权限： 1usermod -s /usr/bin/passwd test #用户telnet后将直接进入改密界面 6.如果要删除用户，用下面代码： 1234 在root用户下： userdel -r newuser 在普通用户下： sudo userdel -r newuser 因为需要彻底删除用户，所以加上-r的选项，在删除用户的同时一起把这个用户的宿主目录和邮件目录删除。 配置完成没有意外的话,这个用户已经可以访问了,但是根据环境不同可能出现不同的错误 如果出现权限不对.可根据下面的修改权限 123chmod [who] [+ | - | =] [mode] 文件名chmod 777 -R /home/text]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java常用的jar包]]></title>
      <url>%2F2017%2F04%2F12%2Fjava%E5%B8%B8%E7%94%A8%E7%9A%84jar%E5%8C%85%2F</url>
      <content type="text"><![CDATA[Java开发中主要用到的jar包介绍commons-io.jar：可以看成是java.io的扩展，用来帮助进行IO功能开发．它包含三个主要的领域:Utilityclasses-提供一些静态方法来完成公共任务．Filters-提供文件过滤器的各种实现．Streams-提供实用的Stream，reader与writer实现． commons-beanutils.jar：提供对Java反射和自省API的包装，主要提供了对于 JavaBean进行各种操作。commons-digester.jar:它能方便地将XML文档所定义的元素转化为JAVA对象，其实它的用法有点象栈(当然内在的原理就是那个古老的东西,只是提供了更高一层的封装)。 commons-lang.jar:它扩展了标准 java.langAPI，增加了字符串操作方法、基本数值方法、对象反射、创建和串行化以及System属性。它还包含一个可继承的enum类型、对多种嵌套的Exception类型的支持、对java.util.Date的增强以及用于构建方法的实用程序，例如自动生成 toString()的结果、自动实现hashCode()和equals()方法、数组操作、枚举、日期和时间的处理等等。ArrayUtils–用于对数组的操作，如添加、查找、删除、子数组、倒序、元素类型转换等；BitField–用于操作位元，提供了一些方便而安全的方法；BooleanUtils–用于操作和转换boolean或者Boolean及相应的数组；CharEncoding–包含了Java环境支持的字符编码，提供是否支持某种编码的判断；CharRange–用于设定字符范围并做相应检查；CharSet–用于设定一组字符作为范围并做相应检查；CharSetUtils–用于操作CharSet；CharUtils–用于操作char值和Character对象；ClassUtils–用于对Java类的操作，不使用反射；ObjectUtils–用于操作Java对象，提供null安全的访问和其他一些功能；RandomStringUtils–用于生成随机的字符串；SerializationUtils–用于处理对象序列化，提供比一般Java序列化更高级的处理能力；StringEscapeUtils–用于正确处理转义字符，产生正确的Java、JavaScript、HTML、XML和SQL代码；StringUtils–处理String的核心类，提供了相当多的功能；SystemUtils–在java.lang.System基础上提供更方便的访问，如用户路径、Java版本、时区、操作系统等判断；Validate–提供验证的操作，有点类似assert断言；WordUtils–用于处理单词大小写、换行等。commons-codec.jar：包含一些通用的编码解码算法。包括一些语音编码器，Hex,Base64, 以及URLencoder。 commons-collections.jar：提供一个类包来扩展和增加标准的JavaCollection框架。Bag接口：适用于包含一个对象的多个拷贝的集合Buffer接口：适用于具有顺序的集合类，例如FIFOs(先进先出)BidiMap(双向映射)：可以通过值查找键，也可以通过键查找值Map迭代器：提供了对映射的快速迭代对类型检查进行了封装，确保特定类的实例可以被添加到集合中对转换进行了封装，将集合中的对象转换成被加入时的类型对集合进行组合，使多个集合看起来就像一个集合一样有序映射和set，保持元素添加时的顺序，包括一个基于LRU的map标识映射可以给予对象的==来比较对象，而不是基于equals方法引用映射可以允许键and/or值可以有控制的进行回收很多比较器的实现很多迭代器的实现从数组或者枚举到集合的适配器用来测试或者创建典型set理论的集合属性，例如与、或、闭包 commons-dbutil.jar:对传统操作数据库的类进行二次封装，可以把结果集转化成List(1)org.apache.commons.dbutilsDbUtils : 提供如关闭连接、装载JDBC驱动程序等常规工作的工具类QueryRunner: 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。QueryLoader: 属性文件加载器，主要用于加载属性文件中的SQL到内存中。(2)org.apache.commons.dbutils.handlersArrayHandler：将ResultSet中第一行的数据转化成对象数组ArrayListHandler将ResultSet中所有的数据转化成List，List中存放的是Object[]BeanHandler：将ResultSet中第一行的数据转化成类对象BeanListHandler：将ResultSet中所有的数据转化成List，List中存放的是类对象ColumnListHandler：将ResultSet中某一列的数据存成List，List中存放的是Object对象KeyedHandler：将ResultSet中存成映射，key为某一列对应为Map。Map中存放的是数据MapHandler：将ResultSet中第一行的数据存成Map映射MapListHandler：将ResultSet中所有的数据存成List。List中存放的是MapScalarHandler：将ResultSet中一条记录的其中某一列的数据存成Object java开发中主要用到的jar包总结axis.jar:SOAP引擎包jaxrpc.jar:Axis运行所需要的组件包saaj.jar:创建到端点的点到点连接的方法、创建并处理SOAP消息和附件的方法，以及接收和处理SOAP错误的方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139wsdl4j-1.5.1.jar:Axis运行所需要的组件包activation.jar:JAF框架的jar包annotations-api.jar:使用注解所需jarant.jar:用于自动化调用程序完成项目的编译，打包，测试等aopalliance-1.0.jar:支持spring AOPasm-2.2.3.jar:ASM字节码库asm-commons-2.2.3.jar:ASM字节码库asm-util-2.2.3.jar:Java字节码操纵和分析框架aspectjrt.jar:处理事务和AOP所需的包aspectjweaver.jar:处理事务和AOP所需的包axiom-api-1.2.7.jar:Axis 对象模型axiom-impl-1.2.7.jar:Axis 对象模型bcprov-jdk15-140.jar:基于java1.5 的加密算法实现bfmclientmodel.jar:使用WebSphere所需jar包bpcclientcore.jar:使用WebSphere所需jar包bpe137650.jar:提供远程访问BPE容器的实现。 bsh-2.0b4.jar:解决负载逻辑运算c3p0-0.9.0.jar:开放源代码的JDBC连接池cglib-nodep-2.1_3.jar:Spring中自动代理所需jar包cobertura.jar:测量测试覆盖率commons-beanutils-1.7.0.jar:动态的获取/设值Java Bean的属性commons-chain-1.1.jar:实现责任链设计模式的Java 类库commons-codec-1.3.jar:用来处理常用的编码方法的工具类包，例如DES、SHA1、MD5、Base64等等commons-collections-3.1.jar:对标准java Collection的扩展commons-collections.jar:对标准java Collection的扩展commons-discovery-0.2.jar:用来发现、查找和实现可插入式接口，提供一些一般类实例化、单件的生命周期管理的常用方法.db2jcc.jarjava连接DB2所需jarcommons-digester-1.8.jar:用于处理struts-config.xml配置文件commons-fileupload-1.1.1.jar:struts上传文件commons-httpclient-3.1.jar:用来简化HTTP客户端与服务器端进行各种通信编程实现commons-io-1.1.jar:针对java.io.InputStream和Reader进行了扩展commons-lang-2.4.jar:对java.lang.*的扩展commons-logging-1.1.1.jar:日志包commons-pool-1.3.jar:实现对象池化框架commons-validator-1.3.1.jar:用来把验证规则程序提取出来，以供重复使用db2jcc_license_cu.jar:java:连接DB2所需jardom4j-1.6.1.jar:解析XMLehcache-1.2.4.jar:hibernate的二级缓存如果用ehcache的时候需要此jar包emf.jar:基于Eclipse的模型框架ezmorph-1.0.6.jar:使用JSON所需的jar包FastInfoset-1.2.2.jar:使用WebService所需的jar包freemarker-2.3.8.jar:Strus2支持的一种表现层框架geronimo-activation_1.1_spec-1.0.2.jar:Apache Geronimo所带jar包，geronimo-annotation_1.0_spec-1.1.1.jar:Apache Geronimo所带jar包geronimo-javamail_1.4_spec-1.3.jar:Apache Geronimo所带jar包geronimo-jaxws_2.1_spec-1.0.jar:Apache Geronimo所带jar包geronimo-jms_1.1_spec-1.1.1.jar:Apache Geronimo所带jar包geronimo-servlet_2.5_spec-1.2.jar:Apache Geronimo所带jar包geronimo-stax-api_1.0_spec-1.0.1.jar:Apache Geronimo所带jar包hibernate3.jar:Hibernate3的核心jar包htmclientmodel.jar:使用WebSphere所需jar包jakarta-oro.jar:一套文本处理工具，提供per15.0兼容的表达式，AWK-like表达式，Glob表达式。javassist.jar:Javassist 字节码解释器jaxb-api-2.1.jar:使用WebService所需的jar包jaxb-impl-2.1.7.jar:使用CXF所需jar包jaxb-xjc-2.1.7.jar:使用CXF所需jar包jaxen-1.1.1.jar:解析XMLjcifs-1.2.22.jar:实现单点登陆jdom2-1.0.jar:解析XMLjdom-1.0.jar:解析XMLjettison-1.0.1.jar:使用CXF所需jar包jetty-6.1.9.jar:Jetty Http服务器jarjetty-util-6.1.9.jar:Jetty Http服务器jarjra-1.0-alpha-4.jar:使用CXF所需jar包js-1.6R7.jar:使用CXF所需jar包json-lib-2.2.3-jdk13.jar:使用JSON所需的jar包jsonplugin-0.25.jar:strus2的JSON插件jsr311-api-0.8.jar:使用CXF所需jar包jstl.jar:JSTL标签库jta.jar:标准的 JAVA 事务处理接口junit.jar:用于单元测试jxl.jar:通过java操作excel表格的工具类库ldap.jar:JNDI目录服务和LDAO服务器所需的jarldapbp.jar:JNDI目录服务和LDAO服务器所需的jarlog4j-1.2.15.jar:提供日志功能mail.jar:java发送邮件jar包neethi-2.0.4.jar:使用CXF所需jar包odmg-3.0.jar:ODMG是一个ORM的规范，Hibernate实现了ODMG规范，这是一个核心的库ognl-2.6.11.jar:struts2中OGNL语言ojdbc14.jar:Oracle数据库驱动包opensaml-1.1.jar:使用CXF所需jar包oro-2.0.8.jar:Validator框架所需的jar包oscache-2.1.jar:Java 对象的缓存工具poi-3.1-FINAL-20080629.jar:操作exce所需jar包poi-contrib-3.1-FINAL-20080629.jar:操作exce所需jar包poi-ooxml-3.6-20091214.jar:提供对office的word、excel、visio及ppt的操作poi-ooxml-schemas-3.6-20091214.jar:提供对office的word、excel、visio及ppt的操作poi-scratchpad-3.1-FINAL-20080629.jar:提供对office的word、excel、visio及ppt的操作processCommon.jarIBM WebSphere:运行所需jarProcessCommonLibrary.jarIBM WebSphere:运行所需jarprocessIdentity.jarIBM WebSphere:运行所需jarProcessInformation.jar:进程监视软件包proxool-0.9.1.jar:数据库连接池proxool-cglib.jar:数据库连接池quartz-1.6.0.jar:开源作业调度框架saaj-api-1.3.jar:使用axis所需的jarsaaj-impl-1.3.2.jar:使用axis所需的jarserializer-2.7.1.jar:XML序列化slf4j-jdk14-1.5.6.jar:整合各种日志框架的工具spring208.jar:spring核心框架spring-ldap-1.2-RC1.jar:spring下LDAPspring-mock.jar:spring的测试框架standard.jar:使用JSTL标签库所需的jarstax-api-1.0.1.jar:解析XMLstruts2-core-2.0.14.jar:struts2核心jarstruts2-spring-plugin-2.0.6.jar:struts2整合Spring所需jartaglibs-datetime.jar:Apache开源组织提供标签库，用于格式化日期。taglibs-mailer.jar:用于发送邮件taglibs-string.jar:Apache开源组织提供标签库，用于对String的操作。task137650.jar:Portal技术在SOA系统集成应用中实现所需的jarutility.jar:Apache开源组织提供标签库velocity-1.5.jar:一个免费的开源模板框架wsdl4j-1.6.2.jar:用来解析服务的WSDl文件wss4j-1.5.4.jar:创建CXF所需jarwstx-asl-3.2.6.jar:创建CXF所需jarxbean-spring-2.8.jar:使用xfire所需jarxerces-2.6.2.jar:XML解析器xfire-all-1.2.6.jar:用于实现WebServiceXmlSchema-1.1.jar:使用xfire所需jarxwork-2.0.7.jar:WebWork核心jar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java-web基本应用]]></title>
      <url>%2F2017%2F04%2F11%2Fjava-web%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Spring Validation（使用Hibernate Validator）判断表单 数据是否空,大小,email…..1、需要的jar包hibernate-validator.5.1.3.Final.jar validation-api.1.1.0.Final.jar 在spring3之后，任何支持JSR303的validator（如Hibernate Validator）都可以通过简单配置引入，只需要在配置xml中加入，这时validatemessage的属性文件默认为classpath下的ValidationMessages.properties：12&lt;!-- support JSR303 annotation if JSR 303 validation present on classpath --&gt;&lt;mvc:annotation-driven /&gt; 注解123456789101112131415161718192021Bean Validation 中内置的 constraint @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 使用在对象中 12345public class Customer &#123; 7 8 @NotEmpty //make sure name is not empty 9 String name;10 在controller中 12345678910111213public class SignUpController &#123;14 15 @RequestMapping(value = &quot;/signup&quot;, method = RequestMethod.POST)16 public String addCustomer(@Valid Customer customer,(这里使用) BindingResult result) &#123;17 18 if (result.hasErrors()) &#123;19 return &quot;SignUpForm&quot;;20 &#125; else &#123;21 return &quot;Done&quot;;22 &#125;23 24 &#125; 文件上传]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ruby脚本进行提交git或git私有库]]></title>
      <url>%2F2017%2F04%2F10%2FRuby%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E6%8F%90%E4%BA%A4git%2F</url>
      <content type="text"><![CDATA[Ruby脚本进行提交git和git私有库简单的ruby脚本 提交git本地 提交git远程 制作好远程私有库,提交到远程私有库 制作好远程公有库github,提交到github github:https://github.com/winsions/RubyToGit.git 用法把文件夹中的 fastlane文件复制到项目的根目录 提交到git (本地和远程) 复制:提到本地git1文件 或者提到远程git2文件cd到项目执行 下面命令 1fastlane ManagerLib message:本次所修改的描述 提交私有库或者公有库 复制:提交到公有库github3文件 或者提交到私有库4文件cd到项目执行 下面命令 1fastlane ManagerLib tag:0.1.0(标签号) target:项目的名字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[有用的网站都在这里]]></title>
      <url>%2F2017%2F04%2F10%2F%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%2F</url>
      <content type="text"><![CDATA[真的有用各种操作系统 工具什么样的都有http://www.itellyou.cn/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo的简单使用]]></title>
      <url>%2F2017%2F04%2F10%2Fhexo%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[hexo的简单使用创建新博客的cd到hexo的根目录文件1hexo new post &quot;hexo的简单使用&quot; (标题) 分布1hexo g 调试模式1hexo s --debug 启动服务1hexo s 上传github1hexo d]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git的简单使用]]></title>
      <url>%2F2017%2F04%2F06%2Fgit%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[git的简单使用查看远程库信息，使用 1git remote -v; 本地新建的分支如果不推送到远程，对其他人就是不可见的; 从本地推送分支，使用 12git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交; 在本地创建和远程分支对应的分支，使用 本地和远程分支的名称最好一致; 1git checkout -b branch-name origin/branch-name， 建立本地分支和远程分支的关联，使用 1git branch --set-upstream branch-name origin/branch-name; 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 分支查看当前在哪个分支1git branch 切换分支1git checkout develop 合并分支1git merge --no-ff develop 创建分支 1git checkout -b feature-x develop 删除分支1git branch -d feature-x 如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。12git push origin test:master // 提交本地test分支作为远程的master分支git push origin test:test // 提交本地test分支作为远程的test分支 1git push --set-upstream origin develop 提交本地分支到远程新的分支 如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。 1git push origin :test // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心 Git回滚分支首先备份当前的master分支，防止回滚失败。 从origin master中新建一个分支，名称随便，比如，master_backup。 备份完成后，将master回滚到指定的版本,注意这个地方，是将本地的master分支回滚到指定的版本1git reset --hard commit-id 回滚本地master完成后，将回滚后的代码push到远端master，覆盖远端master分支。方法为：通过git命令，必须通过命令来，sourcetree的方式不可行。 1git push -f origin master。必须有-f，表示强制的意思。 此时，会要求用户输入远端仓库的用户名和密码，用于确认当前用户具有-f的权限。 push成功后，就可以删除备份的master了。sourcetree的方式也是不可以的1git branch -D master_backup tag 加标签添加标签 12git tag 0.1.0;git tag -a v0.1.2 -m “0.1.2版本” 发布标签12git push origin v0.1.2git push --tags 切换1git checkout [tagname] 删除1git tag -d v0.1.2 # 删除标签 删除远程标签1git push origin :refs/tags/标签名 git远程连接git删除远程连接1git remote rm origin 添加远程连接1git remote add origin 远程仓库地址 1git push --set-upstream origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从iOS转战JavaWeb]]></title>
      <url>%2F2017%2F04%2F01%2F%E4%BB%8EiOS%E8%BD%AC%E6%88%98JavaWeb%2F</url>
      <content type="text"><![CDATA[需要持续不段的学习才行hexo的简单命令12345678910111213hexo new&quot;postName&quot; #新建文章hexo new page&quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[出游小记]]></title>
      <url>%2F2017%2F04%2F01%2Fhello-world%2F</url>
      <content type="text"><![CDATA[贸然的一次出行突然间的放松电脑已经成为我的习惯，突然发现自己好像少了某些重要的东西–电脑，原来已经三天没摸电脑了，电脑已成为我生活的一部分了。但是出游让我学到了其他的存在。 生活随心长时间的办公室生活已经让我不知道改怎么释放自己，总是很在乎别人怎么看，好像自己是在为别人而活。看到一对夫妻在公园玩，高高兴兴的啃着北京方便面，然而有些人却扯着嘴角在笑，他们依然在到处游玩，不要为别人的想法而影响自己，在不影响公共秩序的情况下，做我们自己想做的事情，让自己开心的事情，何乐不为呢。看到某一个逗逼，把吃饭盒放在一个大酒缸的前面，旁边人来人往，自己放了5毛钱，让我给他拍照。我当时的第一想法是：丢不丢人啊，这么多人看着，照片我都不想拍，可是别人都不认识我，我怕什么呢。当然这只是一个最简单的解释，我们玩我们自己的，有没有影响到别人，管他怎么看呢，我开心就好，出来玩嘛本身就图个开心。其实我也想玩很多，但就是怕别人看到笑话，而不敢做，这不是违背了我们出来玩的初衷吗？这并不是没心没肺，只是在生活中腰做真实的自己。关心身边的人，这次被一个向导无微不至的照顾，让我无地自容啊，此处省略一万字。。。。。。 沟通这是人与人的社会，沟通无处不在，如果只有你一个人倒也显得无趣。鼓起勇气只要能开个头，就又可能聊下去，可能又多了一个朋友，或者增长一下见闻，毕竟每一个人的经历都是不同的。比如在飞机上，没手机可玩，大家要么睡觉，要么双眼无神的看着远方，其实和身边的人聊一聊，时间过的也挺快呢，还能了解一下别人的人经历，也有可能就多了一个人生中的朋友，说的庸俗一点，也有可能是你下一个发财的机会。 小结没有文彩，就当记一下流水账喽，发现自己的缺点，就要努力去攻克他，早上走向人生巅峰，赢取心爱的她。]]></content>
    </entry>

    
  
  
</search>
